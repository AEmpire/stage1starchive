<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>解释下"找别人写的最简单的C/C++代码来看,直接放弃编程梦想"</title>
    <link>https://bbs.saraba1st.com/2b/</link>
    <description>解释下"找别人写的最简单的C/C++代码来看,直接放弃编程梦想"</description>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <generator>python-feedgen</generator>
    <lastBuildDate>Thu, 09 Jul 2020 19:17:34 +0000</lastBuildDate>
    <item>
      <title>解释下"找别人写的最简单的C/C++代码来看,直接放弃编程梦想"[50-100]</title>
      <link>https://bbs.saraba1st.com/2b/thread-1844205-1-1.html</link>
      <description>找了一个别人写的最简单的C/C++代码来看，直接放弃编程梦想&#13;
 本帖最后由 CAMUS.net 于 2019-7-4 13:03 编辑 

//////////////////////////////////////////////////////////////////////////
&#13;
//                                                                      //
&#13;
//      6502 CPU core                                                   //
&#13;
//                                                         Norix      //
&#13;
//                                             written   2001/02/22 //
&#13;
//                                             last modify ----/--/-- //
&#13;
//////////////////////////////////////////////////////////////////////////
&#13;
#ifndef      __CPU_INCLUDED__
&#13;
#define      __CPU_INCLUDED__
&#13;
#include "typedef.h"
&#13;
#include "macro.h"
&#13;
class      NES;
&#13;
class      APU;
&#13;
class      Mapper;
&#13;
// 6502 status flags
&#13;
#define      C_FLAG                0x01                // 1: Carry
&#13;
#define      Z_FLAG                0x02                // 1: Zero
&#13;
#define      I_FLAG                0x04                // 1: Irq disabled
&#13;
#define      D_FLAG                0x08                // 1: Decimal mode flag (NES unused)
&#13;
#define      B_FLAG                0x10                // 1: Break
&#13;
#define      R_FLAG                0x20                // 1: Reserved (Always 1)
&#13;
#define      V_FLAG                0x40                // 1: Overflow
&#13;
#define      N_FLAG                0x80                // 1: Negative
&#13;
// Interrupt
&#13;
#define      NMI_FLAG      0x01
&#13;
#define      IRQ_FLAG      0x02
&#13;
#define      IRQ_FRAMEIRQ      0x04
&#13;
#define      IRQ_DPCM      0x08
&#13;
#define      IRQ_MAPPER      0x10
&#13;
#define      IRQ_MAPPER2      0x20
&#13;
#define      IRQ_TRIGGER      0x40                // one shot(旧IRQ())
&#13;
#define      IRQ_TRIGGER2      0x80                // one shot(旧IRQ_NotPending())
&#13;
#define      IRQ_MASK      (~(NMI_FLAG|IRQ_FLAG))
&#13;
// Vector
&#13;
#define      NMI_VECTOR      0xFFFA
&#13;
#define      RES_VECTOR      0xFFFC
&#13;
#define      IRQ_VECTOR      0xFFFE
&#13;
// 6502 context
&#13;
typedef      struct      {
&#13;
      WORD      PC;      /* Program counter   */
&#13;
      BYTE      A;      /* CPU registers   */
&#13;
      BYTE      P;
&#13;
      BYTE      X;
&#13;
      BYTE      Y;
&#13;
      BYTE      S;
&#13;
      BYTE      INT_pending;      // 割り込みペンディングフラグ
&#13;
} R6502;
&#13;
class      CPU
&#13;
{
&#13;
public:
&#13;
      CPU( NES* parent );
&#13;
      virtual      ~CPU();
&#13;
      BYTE      RD6502( WORD addr );
&#13;
      void      WR6502( WORD addr, BYTE data );
&#13;
      WORD      RD6502W( WORD addr );
&#13;
      void      Reset();
&#13;
      void      NMI();
&#13;
      void      SetIRQ( BYTE mask );
&#13;
      void      ClrIRQ( BYTE mask );
&#13;
      void      DMA( INT cycles );
&#13;
      INT      EXEC( INT request_cycles );
&#13;
      INT      GetDmaCycles();
&#13;
      void      SetDmaCycles( INT cycles );
&#13;
      INT      GetTotalCycles();
&#13;
      void      SetTotalCycles( INT cycles );
&#13;
      void      SetContext( R6502 r )      { R = r; }
&#13;
      void      GetContext( R6502&amp; r )      { r = R; }
&#13;
      void      SetClockProcess( BOOL bEnable ) { m_bClockProcess = bEnable; }
&#13;
protected:
&#13;
      NES*      nes;
&#13;
      APU*      apu;
&#13;
      Mapper*      mapper;
&#13;
      R6502      R;
&#13;
      INT      TOTAL_cycles;      // CPUトータルサイクル数
&#13;
      INT      DMA_cycles;      // DMAサイクル数
&#13;
      // PTR
&#13;
      LPBYTE      STACK;
&#13;
      // Zero &amp; Negative table
&#13;
      BYTE      ZN_Table;
&#13;
      // Clock process
&#13;
      BOOL      m_bClockProcess;
&#13;
private:
&#13;
};
&#13;
#endif      // !__CPU_INCLUDED__
&#13;
/*----------------------------------------------------------------------*/
&#13;
/*                                                                      */
&#13;
/*      6502 CPU Core v0.00                                             */
&#13;
/*                                                         Norix      */
&#13;
/*                                             written   2000/12/23 */
&#13;
/*                                             last modify ----/--/-- */
&#13;
/*----------------------------------------------------------------------*/
&#13;
/*--------------[ INCLUDE               ]-------------------------------*/
&#13;
#define      WIN32_LEAN_AND_MEAN
&#13;
#include &lt;windows.h&gt;
&#13;
#include "VirtuaNESres.h"
&#13;
#include "typedef.h"
&#13;
#include "macro.h"
&#13;
#include "DebugOut.h"
&#13;
#include "App.h"
&#13;
#include "Config.h"
&#13;
#include "nes.h"
&#13;
#include "mmu.h"
&#13;
#include "cpu.h"
&#13;
#include "ppu.h"
&#13;
#include "apu.h"
&#13;
#include "rom.h"
&#13;
#include "mapper.h"
&#13;
/*--------------[ DEFINE                ]-------------------------------*/
&#13;
#define      DPCM_SYNCCLOCK      FALSE
&#13;
/*--------------[ EXTERNAL PROGRAM      ]-------------------------------*/
&#13;
/*--------------[ EXTERNAL WORK         ]-------------------------------*/
&#13;
/*--------------[ WORK                  ]-------------------------------*/
&#13;
/*--------------[ CONST               ]-------------------------------*/
&#13;
/*--------------[ PROTOTYPE             ]-------------------------------*/
&#13;
/*--------------[ PROGRAM               ]-------------------------------*/
&#13;
// オペコード
&#13;
//#define      OP6502(A)      RD6502((A))
&#13;
//#define      OP6502W(A)      RD6502W((A))
&#13;
// ゼロページリード
&#13;
#define      ZPRD(A)                (RAM[(BYTE)(A)])
&#13;
//#define      ZPRDW(A)      (*((LPWORD)&amp;RAM[(BYTE)(A)]))
&#13;
#define      ZPRDW(A)      ((WORD)RAM[(BYTE)(A)]+((WORD)RAM[(BYTE)((A)+1)]&lt;&lt;8))
&#13;
#define      ZPWR(A,V)      { RAM[(BYTE)(A)]=(V); }
&#13;
#define      ZPWRW(A,V)      { *((LPWORD)&amp;RAM[(BYTE)(A)])=(WORD)(V); }
&#13;
// サイクルカウンタ
&#13;
#define      ADD_CYCLE(V)      { exec_cycles += (V); }
&#13;
//#define      ADD_CYCLE(V)      {}
&#13;
// EFFECTIVE ADDRESSページ境界超えチェック
&#13;
#define      CHECK_EA()      { if( (ET&amp;0xFF00) != (EA&amp;0xFF00) ) ADD_CYCLE(1); }
&#13;
//#define      CHECK_EA()      { if( (R.PC&amp;0xFF00) != (EA&amp;0xFF00) ) ADD_CYCLE(1); }
&#13;
//#define      CHECK_EA()      {}
&#13;
// フラグ操作
&#13;
// ゼロ／ネガティブフラグのチェックと設定
&#13;
#define      SET_ZN_FLAG(A)      { R.P &amp;= ~(Z_FLAG|N_FLAG); R.P |= ZN_Table[(BYTE)(A)]; }
&#13;
// フラグセット
&#13;
#define      SET_FLAG(V)      { R.P |=(V); }
&#13;
// フラグクリア
&#13;
#define      CLR_FLAG(V)      { R.P &amp;= ~(V); }
&#13;
// フラグテスト＆セット／クリア
&#13;
#define      TST_FLAG(F,V)      { R.P &amp;= ~(V); if((F)) R.P |= (V); }
&#13;
// フラグチェック
&#13;
#define      CHK_FLAG(V)      (R.P&amp;(V))
&#13;
// WT .... WORD TEMP
&#13;
// EA .... EFFECTIVE ADDRESS
&#13;
// ET .... EFFECTIVE ADDRESS TEMP
&#13;
// DT .... DATA
&#13;
#define      MR_IM()      {                \
&#13;
      DT = OP6502( R.PC++ );      \
&#13;
}
&#13;
#define      MR_ZP()      {                \
&#13;
      EA = OP6502( R.PC++ );      \
&#13;
      DT = ZPRD( EA );      \
&#13;
}
&#13;
#define      MR_ZX()      {                \
&#13;
      DT = OP6502( R.PC++ );      \
&#13;
      EA = (BYTE)(DT + R.X);      \
&#13;
      DT = ZPRD( EA );      \
&#13;
}
&#13;
#define      MR_ZY()      {                \
&#13;
      DT = OP6502( R.PC++ );      \
&#13;
      EA = (BYTE)(DT + R.Y);      \
&#13;
      DT = ZPRD( EA );      \
&#13;
}
&#13;
#define      MR_AB()      {                \
&#13;
      EA = OP6502W( R.PC );      \
&#13;
      R.PC += 2;                \
&#13;
      DT = RD6502( EA );      \
&#13;
}
&#13;
#define      MR_AX()      {                \
&#13;
      ET = OP6502W( R.PC );      \
&#13;
      R.PC += 2;                \
&#13;
      EA = ET + R.X;                \
&#13;
      DT = RD6502( EA );      \
&#13;
}
&#13;
#define      MR_AY()      {                \
&#13;
      ET = OP6502W( R.PC );      \
&#13;
      R.PC += 2;                \
&#13;
      EA = ET + R.Y;                \
&#13;
      DT = RD6502( EA );      \
&#13;
}
&#13;
#define      MR_IX()      {                \
&#13;
      DT = OP6502( R.PC++ );      \
&#13;
      EA = ZPRDW( DT + R.X );      \
&#13;
      DT = RD6502( EA );      \
&#13;
}
&#13;
#define      MR_IY()      {                \
&#13;
      DT = OP6502( R.PC++ );      \
&#13;
      ET = ZPRDW( DT );      \
&#13;
      EA = ET + R.Y;                \
&#13;
      DT = RD6502( EA );      \
&#13;
}
&#13;
// EFFECTIVE ADDRESS
&#13;
#define      EA_ZP()      {                \
&#13;
      EA = OP6502( R.PC++ );      \
&#13;
}
&#13;
#define      EA_ZX()      {                \
&#13;
      DT = OP6502( R.PC++ );      \
&#13;
      EA = (BYTE)(DT + R.X);      \
&#13;
}
&#13;
#define      EA_ZY()      {                \
&#13;
      DT = OP6502( R.PC++ );      \
&#13;
      EA = (BYTE)(DT + R.Y);      \
&#13;
}
&#13;
#define      EA_AB()      {                \
&#13;
      EA = OP6502W( R.PC );      \
&#13;
      R.PC += 2;                \
&#13;
}
&#13;
#define      EA_AX()      {                \
&#13;
      ET = OP6502W( R.PC );      \
&#13;
      R.PC += 2;                \
&#13;
      EA = ET + R.X;                \
&#13;
}
&#13;
#define      EA_AY()      {                \
&#13;
      ET = OP6502W( R.PC );      \
&#13;
      R.PC += 2;                \
&#13;
      EA = ET + R.Y;                \
&#13;
}
&#13;
#define      EA_IX()      {                \
&#13;
      DT = OP6502( R.PC++ );      \
&#13;
      EA = ZPRDW( DT + R.X );      \
&#13;
}
&#13;
#define      EA_IY()      {                \
&#13;
      DT = OP6502( R.PC++ );      \
&#13;
      ET = ZPRDW( DT );      \
&#13;
      EA = ET + (WORD)R.Y;      \
&#13;
}
&#13;
// メモリライト
&#13;
#define      MW_ZP()                ZPWR(EA,DT)
&#13;
#define      MW_EA()                WR6502(EA,DT)
&#13;
// STACK操作
&#13;
#define      PUSH(V)                { STACK[(R.S--)&amp;0xFF]=(V); }
&#13;
#define      POP()                STACK[(++R.S)&amp;0xFF]
&#13;
// 算術演算系
&#13;
/* ADC (NV----ZC) */
&#13;
#define      ADC() {                                                      \
&#13;
      WT = R.A+DT+(R.P&amp;C_FLAG);                              \
&#13;
      TST_FLAG( WT &gt; 0xFF, C_FLAG );                              \
&#13;
      TST_FLAG( ((~(R.A^DT))&amp;(R.A^WT)&amp;0x80), V_FLAG );      \
&#13;
      R.A = (BYTE)WT;                                                \
&#13;
      SET_ZN_FLAG(R.A);                                        \
&#13;
}
&#13;
/* SBC (NV----ZC) */
&#13;
#define      SBC() {                                                \
&#13;
      WT = R.A-DT-(~R.P&amp;C_FLAG);                        \
&#13;
      TST_FLAG( ((R.A^DT) &amp; (R.A^WT)&amp;0x80), V_FLAG );      \
&#13;
      TST_FLAG( WT &lt; 0x100, C_FLAG );                        \
&#13;
      R.A = (BYTE)WT;                                        \
&#13;
      SET_ZN_FLAG(R.A);                              \
&#13;
}
&#13;
/* INC (N-----Z-) */
&#13;
#define      INC() {                        \
&#13;
      DT++;                        \
&#13;
      SET_ZN_FLAG(DT);      \
&#13;
}
&#13;
/* INX (N-----Z-) */
&#13;
#define      INX() {                        \
&#13;
      R.X++;                        \
&#13;
      SET_ZN_FLAG(R.X);      \
&#13;
}
&#13;
/* INY (N-----Z-) */
&#13;
#define      INY() {                        \
&#13;
      R.Y++;                        \
&#13;
      SET_ZN_FLAG(R.Y);      \
&#13;
}
&#13;
/* DEC (N-----Z-) */
&#13;
#define      DEC() {                        \
&#13;
      DT--;                        \
&#13;
      SET_ZN_FLAG(DT);      \
&#13;
}
&#13;
/* DEX (N-----Z-) */
&#13;
#define      DEX() {                        \
&#13;
      R.X--;                        \
&#13;
      SET_ZN_FLAG(R.X);      \
&#13;
}
&#13;
/* DEY (N-----Z-) */
&#13;
#define      DEY() {                        \
&#13;
      R.Y--;                        \
&#13;
      SET_ZN_FLAG(R.Y);      \
&#13;
}
&#13;
// 論理演算系
&#13;
/* AND (N-----Z-) */
&#13;
#define      AND() {                        \
&#13;
      R.A &amp;= DT;                \
&#13;
      SET_ZN_FLAG(R.A);      \
&#13;
}
&#13;
/* ORA (N-----Z-) */
&#13;
#define      ORA() {                        \
&#13;
      R.A |= DT;                \
&#13;
      SET_ZN_FLAG(R.A);      \
&#13;
}
&#13;
/* EOR (N-----Z-) */
&#13;
#define      EOR() {                        \
&#13;
      R.A ^= DT;                \
&#13;
      SET_ZN_FLAG(R.A);      \
&#13;
}
&#13;
/* ASL_A (N-----ZC) */
&#13;
#define      ASL_A() {                        \
&#13;
      TST_FLAG( R.A&amp;0x80, C_FLAG );      \
&#13;
      R.A &lt;&lt;= 1;                        \
&#13;
      SET_ZN_FLAG(R.A);                \
&#13;
}
&#13;
/* ASL (N-----ZC) */
&#13;
#define      ASL() {                              \
&#13;
      TST_FLAG( DT&amp;0x80, C_FLAG );      \
&#13;
      DT &lt;&lt;= 1;                        \
&#13;
      SET_ZN_FLAG(DT);                \
&#13;
}
&#13;
/* LSR_A (N-----ZC) */
&#13;
#define      LSR_A() {                        \
&#13;
      TST_FLAG( R.A&amp;0x01, C_FLAG );      \
&#13;
      R.A &gt;&gt;= 1;                        \
&#13;
      SET_ZN_FLAG(R.A);                \
&#13;
}
&#13;
/* LSR (N-----ZC) */
&#13;
#define      LSR() {                              \
&#13;
      TST_FLAG( DT&amp;0x01, C_FLAG );      \
&#13;
      DT &gt;&gt;= 1;                        \
&#13;
      SET_ZN_FLAG(DT);                \
&#13;
}
&#13;
/* ROL_A (N-----ZC) */
&#13;
#define      ROL_A() {                              \
&#13;
      if( R.P &amp; C_FLAG ) {                        \
&#13;
                TST_FLAG(R.A&amp;0x80,C_FLAG);      \
&#13;
                R.A = (R.A&lt;&lt;1)|0x01;                \
&#13;
      } else {                              \
&#13;
                TST_FLAG(R.A&amp;0x80,C_FLAG);      \
&#13;
                R.A &lt;&lt;= 1;                        \
&#13;
      }                                        \
&#13;
      SET_ZN_FLAG(R.A);                        \
&#13;
}
&#13;
/* ROL (N-----ZC) */
&#13;
#define      ROL() {                                        \
&#13;
      if( R.P &amp; C_FLAG ) {                        \
&#13;
                TST_FLAG(DT&amp;0x80,C_FLAG);      \
&#13;
                DT = (DT&lt;&lt;1)|0x01;                \
&#13;
      } else {                              \
&#13;
                TST_FLAG(DT&amp;0x80,C_FLAG);      \
&#13;
                DT &lt;&lt;= 1;                        \
&#13;
      }                                        \
&#13;
      SET_ZN_FLAG(DT);                        \
&#13;
}
&#13;
/* ROR_A (N-----ZC) */
&#13;
#define      ROR_A() {                              \
&#13;
      if( R.P &amp; C_FLAG ) {                        \
&#13;
                TST_FLAG(R.A&amp;0x01,C_FLAG);      \
&#13;
                R.A = (R.A&gt;&gt;1)|0x80;                \
&#13;
      } else {                              \
&#13;
                TST_FLAG(R.A&amp;0x01,C_FLAG);      \
&#13;
                R.A &gt;&gt;= 1;                        \
&#13;
      }                                        \
&#13;
      SET_ZN_FLAG(R.A);                        \
&#13;
}
&#13;
/* ROR (N-----ZC) */
&#13;
#define      ROR() {                                        \
&#13;
      if( R.P &amp; C_FLAG ) {                        \
&#13;
                TST_FLAG(DT&amp;0x01,C_FLAG);      \
&#13;
                DT = (DT&gt;&gt;1)|0x80;                \
&#13;
      } else {                              \
&#13;
                TST_FLAG(DT&amp;0x01,C_FLAG);      \
&#13;
                DT &gt;&gt;= 1;                        \
&#13;
      }                                        \
&#13;
      SET_ZN_FLAG(DT);                        \
&#13;
}
&#13;
/* BIT (NV----Z-) */
&#13;
#define      BIT() {                                        \
&#13;
      TST_FLAG( (DT&amp;R.A)==0, Z_FLAG );      \
&#13;
      TST_FLAG( DT&amp;0x80, N_FLAG );                \
&#13;
      TST_FLAG( DT&amp;0x40, V_FLAG );                \
&#13;
}
&#13;
// ロード／ストア系
&#13;
/* LDA (N-----Z-) */
&#13;
#define      LDA()      { R.A = DT; SET_ZN_FLAG(R.A); }
&#13;
/* LDX (N-----Z-) */
&#13;
#define      LDX()      { R.X = DT; SET_ZN_FLAG(R.X); }
&#13;
/* LDY (N-----Z-) */
&#13;
#define      LDY()      { R.Y = DT; SET_ZN_FLAG(R.Y); }
&#13;
/* STA (--------) */
&#13;
#define      STA()      { DT = R.A; }
&#13;
/* STX (--------) */
&#13;
#define      STX()      { DT = R.X; }
&#13;
/* STY (--------) */
&#13;
#define      STY()      { DT = R.Y; }
&#13;
/* TAX (N-----Z-) */
&#13;
#define      TAX()      { R.X = R.A; SET_ZN_FLAG(R.X); }
&#13;
/* TXA (N-----Z-) */
&#13;
#define      TXA()      { R.A = R.X; SET_ZN_FLAG(R.A); }
&#13;
/* TAY (N-----Z-) */
&#13;
#define      TAY()      { R.Y = R.A; SET_ZN_FLAG(R.Y); }
&#13;
/* TYA (N-----Z-) */
&#13;
#define      TYA()      { R.A = R.Y; SET_ZN_FLAG(R.A); }
&#13;
/* TSX (N-----Z-) */
&#13;
#define      TSX()      { R.X = R.S; SET_ZN_FLAG(R.X); }
&#13;
/* TXS (--------) */
&#13;
#define      TXS()      { R.S = R.X; }
&#13;
// 比較系
&#13;
/* CMP (N-----ZC) */
&#13;
#define      CMP_() {                              \
&#13;
      WT = (WORD)R.A - (WORD)DT;                \
&#13;
      TST_FLAG( (WT&amp;0x8000)==0, C_FLAG );      \
&#13;
      SET_ZN_FLAG( (BYTE)WT );                \
&#13;
}
&#13;
/* CPX (N-----ZC) */
&#13;
#define      CPX() {                                        \
&#13;
      WT = (WORD)R.X - (WORD)DT;                \
&#13;
      TST_FLAG( (WT&amp;0x8000)==0, C_FLAG );      \
&#13;
      SET_ZN_FLAG( (BYTE)WT );                \
&#13;
}
&#13;
/* CPY (N-----ZC) */
&#13;
#define      CPY() {                                        \
&#13;
      WT = (WORD)R.Y - (WORD)DT;                \
&#13;
      TST_FLAG( (WT&amp;0x8000)==0, C_FLAG );      \
&#13;
      SET_ZN_FLAG( (BYTE)WT );                \
&#13;
}
&#13;
// ジャンプ／リターン系
&#13;
#if      1
&#13;
#define      JMP_ID() {                              \
&#13;
      WT = OP6502W(R.PC);                        \
&#13;
      EA = RD6502(WT);                        \
&#13;
      WT = (WT&amp;0xFF00)|((WT+1)&amp;0x00FF);      \
&#13;
      R.PC = EA+RD6502(WT)*0x100;                \
&#13;
}
&#13;
#else
&#13;
#define      JMP_ID() {                \
&#13;
      ET = OP6502W(R.PC);      \
&#13;
      EA = RD6502W(ET);      \
&#13;
      R.PC = EA;                \
&#13;
}
&#13;
#endif
&#13;
#define      JMP() {                        \
&#13;
      R.PC = OP6502W( R.PC );      \
&#13;
}
&#13;
#define      JSR() {                        \
&#13;
      EA = OP6502W( R.PC );      \
&#13;
      R.PC++;                        \
&#13;
      PUSH( R.PC&gt;&gt;8 );      \
&#13;
      PUSH( R.PC&amp;0xFF );      \
&#13;
      R.PC = EA;                \
&#13;
}
&#13;
#define      RTS() {                        \
&#13;
      R.PC= POP();                \
&#13;
      R.PC |= POP()*0x0100;      \
&#13;
      R.PC++;                        \
&#13;
}
&#13;
#define      RTI() {                        \
&#13;
      R.P   = POP() | R_FLAG;      \
&#13;
      R.PC= POP();                \
&#13;
      R.PC |= POP()*0x0100;      \
&#13;
}
&#13;
#define      _NMI() {                        \
&#13;
      PUSH( R.PC&gt;&gt;8 );                \
&#13;
      PUSH( R.PC&amp;0xFF );                \
&#13;
      CLR_FLAG( B_FLAG );                \
&#13;
      PUSH( R.P );                        \
&#13;
      SET_FLAG( I_FLAG );                \
&#13;
      R.PC = RD6502W(NMI_VECTOR);      \
&#13;
      exec_cycles += 7;                \
&#13;
}
&#13;
#define      _IRQ() {                        \
&#13;
      PUSH( R.PC&gt;&gt;8 );                \
&#13;
      PUSH( R.PC&amp;0xFF );                \
&#13;
      CLR_FLAG( B_FLAG );                \
&#13;
      PUSH( R.P );                        \
&#13;
      SET_FLAG( I_FLAG );                \
&#13;
      R.PC = RD6502W(IRQ_VECTOR);      \
&#13;
      exec_cycles += 7;                \
&#13;
}
&#13;
#define      BRK() {                              \
&#13;
      R.PC++;                              \
&#13;
      PUSH( R.PC&gt;&gt;8 );                \
&#13;
      PUSH( R.PC&amp;0xFF );                \
&#13;
      SET_FLAG( B_FLAG );                \
&#13;
      PUSH( R.P );                        \
&#13;
      SET_FLAG( I_FLAG );                \
&#13;
      R.PC = RD6502W(IRQ_VECTOR);      \
&#13;
}
&#13;
#if      1
&#13;
#define      REL_JUMP() {                \
&#13;
      ET = R.PC;                \
&#13;
      EA = R.PC + (SBYTE)DT;      \
&#13;
      R.PC = EA;                \
&#13;
      ADD_CYCLE(1);                \
&#13;
      CHECK_EA();                \
&#13;
}
&#13;
#else
&#13;
#define      REL_JUMP() {                        \
&#13;
      R.PC = R.PC + (SBYTE)DT;      \
&#13;
      ADD_CYCLE(1);                        \
&#13;
}
&#13;
#endif
&#13;
#define      BCC()      { if( !(R.P &amp; C_FLAG) ) REL_JUMP(); }
&#13;
#define      BCS()      { if((R.P &amp; C_FLAG) ) REL_JUMP(); }
&#13;
#define      BNE()      { if( !(R.P &amp; Z_FLAG) ) REL_JUMP(); }
&#13;
#define      BEQ()      { if((R.P &amp; Z_FLAG) ) REL_JUMP(); }
&#13;
#define      BPL()      { if( !(R.P &amp; N_FLAG) ) REL_JUMP(); }
&#13;
#define      BMI()      { if((R.P &amp; N_FLAG) ) REL_JUMP(); }
&#13;
#define      BVC()      { if( !(R.P &amp; V_FLAG) ) REL_JUMP(); }
&#13;
#define      BVS()      { if((R.P &amp; V_FLAG) ) REL_JUMP(); }
&#13;
// フラグ制御系
&#13;
#define      CLC()      { R.P &amp;= ~C_FLAG; }
&#13;
#define      CLD()      { R.P &amp;= ~D_FLAG; }
&#13;
#define      CLI()      { R.P &amp;= ~I_FLAG; }
&#13;
#define      CLV()      { R.P &amp;= ~V_FLAG; }
&#13;
#define      SEC()      { R.P |= C_FLAG; }
&#13;
#define      SED()      { R.P |= D_FLAG; }
&#13;
#define      SEI()      { R.P |= I_FLAG; }
&#13;
// Unofficial命令
&#13;
#define      ANC()      {                        \
&#13;
      R.A &amp;= DT;                        \
&#13;
      SET_ZN_FLAG( R.A );                \
&#13;
      TST_FLAG( R.P&amp;N_FLAG, C_FLAG );      \
&#13;
}
&#13;
#define      ANE()      {                        \
&#13;
      R.A = (R.A|0xEE)&amp;R.X&amp;DT;      \
&#13;
      SET_ZN_FLAG( R.A );                \
&#13;
}
&#13;
#define      ARR()      {                              \
&#13;
      DT &amp;= R.A;                              \
&#13;
      R.A = (DT&gt;&gt;1)|((R.P&amp;C_FLAG)&lt;&lt;7);      \
&#13;
      SET_ZN_FLAG( R.A );                        \
&#13;
      TST_FLAG( R.A&amp;0x40, C_FLAG );                \
&#13;
      TST_FLAG( (R.A&gt;&gt;6)^(R.A&gt;&gt;5), V_FLAG );      \
&#13;
}
&#13;
#define      ASR()      {                        \
&#13;
      DT &amp;= R.A;                        \
&#13;
      TST_FLAG( DT&amp;0x01, C_FLAG );      \
&#13;
      R.A = DT&gt;&gt;1;                        \
&#13;
      SET_ZN_FLAG( R.A );                \
&#13;
}
&#13;
#define      DCP()      {                        \
&#13;
      DT--;                              \
&#13;
      CMP_();                              \
&#13;
}
&#13;
#define      DOP()      {                        \
&#13;
      R.PC++;                              \
&#13;
}
&#13;
#define      ISB()      {                        \
&#13;
      DT++;                              \
&#13;
      SBC();                              \
&#13;
}
&#13;
#define      LAS()      {                        \
&#13;
      R.A = R.X = R.S = (R.S &amp; DT);      \
&#13;
      SET_ZN_FLAG( R.A );                \
&#13;
}
&#13;
#define      LAX()      {                        \
&#13;
      R.A = DT;                        \
&#13;
      R.X = R.A;                        \
&#13;
      SET_ZN_FLAG( R.A );                \
&#13;
}
&#13;
#define      LXA()      {                        \
&#13;
      R.A = R.X = ((R.A|0xEE)&amp;DT);      \
&#13;
      SET_ZN_FLAG( R.A );                \
&#13;
}
&#13;
#define      RLA()      {                              \
&#13;
      if( R.P &amp; C_FLAG ) {                        \
&#13;
                TST_FLAG( DT&amp;0x80, C_FLAG );      \
&#13;
                DT = (DT&lt;&lt;1)|1;                        \
&#13;
      } else {                              \
&#13;
                TST_FLAG( DT&amp;0x80, C_FLAG );      \
&#13;
                DT &lt;&lt;= 1;                        \
&#13;
      }                                        \
&#13;
      R.A &amp;= DT;                              \
&#13;
      SET_ZN_FLAG( R.A );                        \
&#13;
}
&#13;
#define      RRA()      {                              \
&#13;
      if( R.P &amp; C_FLAG ) {                        \
&#13;
                TST_FLAG( DT&amp;0x01, C_FLAG );      \
&#13;
                DT = (DT&gt;&gt;1)|0x80;                \
&#13;
      } else {                              \
&#13;
                TST_FLAG( DT&amp;0x01, C_FLAG );      \
&#13;
                DT &gt;&gt;= 1;                        \
&#13;
      }                                        \
&#13;
      ADC();                                        \
&#13;
}
&#13;
#define      SAX()      {                        \
&#13;
      DT = R.A &amp; R.X;                        \
&#13;
}
&#13;
#define      SBX()      {                        \
&#13;
      WT = (R.A&amp;R.X)-DT;                \
&#13;
      TST_FLAG( WT &lt; 0x100, C_FLAG );      \
&#13;
      R.X = WT&amp;0xFF;                        \
&#13;
      SET_ZN_FLAG( R.X );                \
&#13;
}
&#13;
#define      SHA()      {                              \
&#13;
      DT = R.A &amp; R.X &amp; (BYTE)((EA&gt;&gt;8)+1);      \
&#13;
}
&#13;
#define      SHS()      {                        \
&#13;
      R.S = R.A &amp; R.X;                \
&#13;
      DT = R.S &amp; (BYTE)((EA&gt;&gt;8)+1);      \
&#13;
}
&#13;
#define      SHX()      {                        \
&#13;
      DT = R.X &amp; (BYTE)((EA&gt;&gt;8)+1);      \
&#13;
}
&#13;
#define      SHY()      {                        \
&#13;
      DT = R.Y &amp; (BYTE)((EA&gt;&gt;8)+1);      \
&#13;
}
&#13;
#define      SLO()      {                        \
&#13;
      TST_FLAG( DT&amp;0x80, C_FLAG );      \
&#13;
      DT &lt;&lt;= 1;                        \
&#13;
      R.A |= DT;                        \
&#13;
      SET_ZN_FLAG( R.A );                \
&#13;
}
&#13;
#define      SRE()      {                        \
&#13;
      TST_FLAG( DT&amp;0x01, C_FLAG );      \
&#13;
      DT &gt;&gt;= 1;                        \
&#13;
      R.A ^= DT;                        \
&#13;
      SET_ZN_FLAG( R.A );                \
&#13;
}
&#13;
#define      TOP()      {                        \
&#13;
      R.PC += 2;                        \
&#13;
}
&#13;
//
&#13;
// コンストラクタ/デストラクタ
&#13;
//
&#13;
//CPU::CPU( NES* parent )
&#13;
CPU::CPU( NES* parent ) : nes(parent)
&#13;
{
&#13;
//      nes = parent;
&#13;
      m_bClockProcess = FALSE;
&#13;
}
&#13;
CPU::~CPU()
&#13;
{
&#13;
}
&#13;
// メモリアクセス
&#13;
//#define      OP6502(A)      (CPU_MEM_BANK[(A)&gt;&gt;13][(A)&amp;0x1FFF])
&#13;
//#define      OP6502W(A)      (*((WORD*)&amp;CPU_MEM_BANK[(A)&gt;&gt;13][(A)&amp;0x1FFF]))
&#13;
#if      0
&#13;
#define      OP6502(A)      RD6502((A))
&#13;
#define      OP6502W(A)      RD6502W((A))
&#13;
#else
&#13;
inline      BYTE      OP6502( WORD addr )
&#13;
{
&#13;
      return      CPU_MEM_BANK;
&#13;
}
&#13;
inline      WORD      OP6502W( WORD addr )
&#13;
{
&#13;
#if      0
&#13;
      WORD      ret;
&#13;
      ret= (WORD)CPU_MEM_BANK[(addr+0)&gt;&gt;13][(addr+0)&amp;0x1FFF];
&#13;
      ret |= (WORD)CPU_MEM_BANK[(addr+1)&gt;&gt;13][(addr+1)&amp;0x1FFF]&lt;&lt;8;
&#13;
      return      ret;
&#13;
#else
&#13;
      return      *((WORD*)&amp;CPU_MEM_BANK);
&#13;
#endif
&#13;
}
&#13;
#endif
&#13;
inline      BYTE      CPU::RD6502( WORD addr )
&#13;
{
&#13;
      if( addr &lt; 0x2000 ) {
&#13;
      // RAM (Mirror $0800, $1000, $1800)
&#13;
                return      RAM;
&#13;
      } else if( addr &lt; 0x8000 ) {
&#13;
      // Others
&#13;
                return      nes-&gt;Read( addr );
&#13;
      } else {
&#13;
      // Dummy access
&#13;
                mapper-&gt;Read( addr, CPU_MEM_BANK );
&#13;
      }
&#13;
      // Quick bank read
&#13;
      return      CPU_MEM_BANK;
&#13;
}
&#13;
inline      WORD      CPU::RD6502W( WORD addr )
&#13;
{
&#13;
      if( addr &lt; 0x2000 ) {
&#13;
      // RAM (Mirror $0800, $1000, $1800)
&#13;
                return      *((WORD*)&amp;RAM);
&#13;
      } else if( addr &lt; 0x8000 ) {
&#13;
      // Others
&#13;
                return      (WORD)nes-&gt;Read(addr)+(WORD)nes-&gt;Read(addr+1)*0x100;
&#13;
      }
&#13;
      // Quick bank read
&#13;
#if      0
&#13;
      WORD      ret;
&#13;
      ret= (WORD)CPU_MEM_BANK[(addr+0)&gt;&gt;13][(addr+0)&amp;0x1FFF];
&#13;
      ret |= (WORD)CPU_MEM_BANK[(addr+1)&gt;&gt;13][(addr+1)&amp;0x1FFF]&lt;&lt;8;
&#13;
      return      ret;
&#13;
#else
&#13;
      return      *((WORD*)&amp;CPU_MEM_BANK);
&#13;
#endif
&#13;
}
&#13;
// メモリライト
&#13;
inline      void      CPU::WR6502( WORD addr, BYTE data )
&#13;
{
&#13;
      if( addr &lt; 0x2000 ) {
&#13;
      // RAM (Mirror $0800, $1000, $1800)
&#13;
                RAM = data;
&#13;
      } else {
&#13;
      // Others
&#13;
                nes-&gt;Write( addr, data );
&#13;
      }
&#13;
}
&#13;
//
&#13;
// リセット
&#13;
//
&#13;
void      CPU::Reset()
&#13;
{
&#13;
      apu = nes-&gt;apu;
&#13;
      mapper = nes-&gt;mapper;
&#13;
      R.A= 0x00;
&#13;
      R.X= 0x00;
&#13;
      R.Y= 0x00;
&#13;
      R.S= 0xFF;
&#13;
      R.P= Z_FLAG|R_FLAG;
&#13;
      R.PC = RD6502W(RES_VECTOR);
&#13;
      R.INT_pending = 0;
&#13;
      TOTAL_cycles = 0;
&#13;
      DMA_cycles = 0;
&#13;
      // STACK quick access
&#13;
      STACK = &amp;RAM;
&#13;
      // Zero/Negative FLAG
&#13;
      ZN_Table = Z_FLAG;
&#13;
      for( INT i = 1; i &lt; 256; i++ )
&#13;
                ZN_Table = (i &amp; 0x80)?N_FLAG:0;
&#13;
}
&#13;
INT      CPU::GetDmaCycles()
&#13;
{
&#13;
      return      DMA_cycles;
&#13;
}
&#13;
void      CPU::SetDmaCycles( INT cycles )
&#13;
{
&#13;
      DMA_cycles = cycles;
&#13;
}
&#13;
INT      CPU::GetTotalCycles()
&#13;
{
&#13;
      return      TOTAL_cycles;
&#13;
}
&#13;
void      CPU::SetTotalCycles( INT cycles )
&#13;
{
&#13;
      TOTAL_cycles = cycles;
&#13;
}
&#13;
//
&#13;
// DMAペンディングサイクル設定
&#13;
//
&#13;
void      CPU::DMA( INT cycles )
&#13;
{
&#13;
      DMA_cycles += cycles;
&#13;
}
&#13;
static      int      nmicount;
&#13;
//
&#13;
// 割り込み
&#13;
//
&#13;
void      CPU::NMI()
&#13;
{
&#13;
      R.INT_pending |= NMI_FLAG;
&#13;
      nmicount = 0;
&#13;
}
&#13;
void      CPU::SetIRQ( BYTE mask )
&#13;
{
&#13;
      R.INT_pending |= mask;
&#13;
}
&#13;
void      CPU::ClrIRQ( BYTE mask )
&#13;
{
&#13;
      R.INT_pending &amp;= ~mask;
&#13;
}
&#13;
//
&#13;
// 命令実行
&#13;
//
&#13;
INT      CPU::EXEC( INT request_cycles )
&#13;
{
&#13;
BYTE      opcode;                // オペコード
&#13;
INT      OLD_cycles = TOTAL_cycles;
&#13;
INT      exec_cycles;
&#13;
BYTE      nmi_request, irq_request;
&#13;
BOOL      bClockProcess = m_bClockProcess;
&#13;
// TEMP
&#13;
register WORD      EA;
&#13;
register WORD      ET;
&#13;
register WORD      WT;
&#13;
register BYTE      DT;
&#13;
      while( request_cycles &gt; 0 ) {
&#13;
                exec_cycles = 0;
&#13;
                if( DMA_cycles ) {
&#13;
                        if( request_cycles &lt;= DMA_cycles ) {
&#13;
                              DMA_cycles -= request_cycles;
&#13;
                              TOTAL_cycles += request_cycles;
&#13;
                              // クロック同期処理
&#13;
                              mapper-&gt;Clock( request_cycles );
&#13;
#if      DPCM_SYNCCLOCK
&#13;
                              apu-&gt;SyncDPCM( request_cycles );
&#13;
#endif
&#13;
                              if( bClockProcess ) {
&#13;
                                        nes-&gt;Clock( request_cycles );
&#13;
                              }
&#13;
//                              nes-&gt;Clock( request_cycles );
&#13;
                              goto      _execute_exit;
&#13;
                        } else {
&#13;
                              exec_cycles += DMA_cycles;
&#13;
//                              request_cycles -= DMA_cycles;
&#13;
                              DMA_cycles = 0;
&#13;
                        }
&#13;
                }
&#13;
                nmi_request = irq_request = 0;
&#13;
                opcode = OP6502( R.PC++ );
&#13;
                if( R.INT_pending ) {
&#13;
                        if( R.INT_pending &amp; NMI_FLAG ) {
&#13;
                              nmi_request = 0xFF;
&#13;
                              R.INT_pending &amp;= ~NMI_FLAG;
&#13;
                        } else
&#13;
                        if( R.INT_pending &amp; IRQ_MASK ) {
&#13;
                              R.INT_pending &amp;= ~IRQ_TRIGGER2;
&#13;
                              if( !(R.P &amp; I_FLAG) &amp;&amp; opcode != 0x40 ) {
&#13;
                                        irq_request = 0xFF;
&#13;
                                        R.INT_pending &amp;= ~IRQ_TRIGGER;
&#13;
                              }
&#13;
                        }
&#13;
                }
&#13;
                switch( opcode ) {
&#13;
                        case      0x69: // ADC #$??
&#13;
                              MR_IM(); ADC();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x65: // ADC $??
&#13;
                              MR_ZP(); ADC();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0x75: // ADC $??,X
&#13;
                              MR_ZX(); ADC();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x6D: // ADC $????
&#13;
                              MR_AB(); ADC();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x7D: // ADC $????,X
&#13;
                              MR_AX(); ADC(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x79: // ADC $????,Y
&#13;
                              MR_AY(); ADC(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x61: // ADC ($??,X)
&#13;
                              MR_IX(); ADC();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x71: // ADC ($??),Y
&#13;
                              MR_IY(); ADC(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xE9: // SBC #$??
&#13;
                              MR_IM(); SBC();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xE5: // SBC $??
&#13;
                              MR_ZP(); SBC();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0xF5: // SBC $??,X
&#13;
                              MR_ZX(); SBC();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xED: // SBC $????
&#13;
                              MR_AB(); SBC();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xFD: // SBC $????,X
&#13;
                              MR_AX(); SBC(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xF9: // SBC $????,Y
&#13;
                              MR_AY(); SBC(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xE1: // SBC ($??,X)
&#13;
                              MR_IX(); SBC();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0xF1: // SBC ($??),Y
&#13;
                              MR_IY(); SBC(); CHECK_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0xC6: // DEC $??
&#13;
                              MR_ZP(); DEC();      MW_ZP();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0xD6: // DEC $??,X
&#13;
                              MR_ZX(); DEC(); MW_ZP();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0xCE: // DEC $????
&#13;
                              MR_AB(); DEC(); MW_EA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0xDE: // DEC $????,X
&#13;
                              MR_AX(); DEC(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0xCA: // DEX
&#13;
                              DEX();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x88: // DEY
&#13;
                              DEY();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xE6: // INC $??
&#13;
                              MR_ZP(); INC(); MW_ZP();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0xF6: // INC $??,X
&#13;
                              MR_ZX(); INC(); MW_ZP();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0xEE: // INC $????
&#13;
                              MR_AB(); INC(); MW_EA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0xFE: // INC $????,X
&#13;
                              MR_AX(); INC(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0xE8: // INX
&#13;
                              INX();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xC8: // INY
&#13;
                              INY();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x29: // AND #$??
&#13;
                              MR_IM(); AND();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x25: // AND $??
&#13;
                              MR_ZP(); AND();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0x35: // AND $??,X
&#13;
                              MR_ZX(); AND();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x2D: // AND $????
&#13;
                              MR_AB(); AND();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x3D: // AND $????,X
&#13;
                              MR_AX(); AND(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x39: // AND $????,Y
&#13;
                              MR_AY(); AND(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x21: // AND ($??,X)
&#13;
                              MR_IX(); AND();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x31: // AND ($??),Y
&#13;
                              MR_IY(); AND(); CHECK_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x0A: // ASL A
&#13;
                              ASL_A();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x06: // ASL $??
&#13;
                              MR_ZP(); ASL(); MW_ZP();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x16: // ASL $??,X
&#13;
                              MR_ZX(); ASL(); MW_ZP();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x0E: // ASL $????
&#13;
                              MR_AB(); ASL(); MW_EA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x1E: // ASL $????,X
&#13;
                              MR_AX(); ASL(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0x24: // BIT $??
&#13;
                              MR_ZP(); BIT();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0x2C: // BIT $????
&#13;
                              MR_AB(); BIT();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x49: // EOR #$??
&#13;
                              MR_IM(); EOR();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x45: // EOR $??
&#13;
                              MR_ZP(); EOR();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0x55: // EOR $??,X
&#13;
                              MR_ZX(); EOR();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x4D: // EOR $????
&#13;
                              MR_AB(); EOR();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x5D: // EOR $????,X
&#13;
                              MR_AX(); EOR(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x59: // EOR $????,Y
&#13;
                              MR_AY(); EOR(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x41: // EOR ($??,X)
&#13;
                              MR_IX(); EOR();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x51: // EOR ($??),Y
&#13;
                              MR_IY(); EOR(); CHECK_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x4A: // LSR A
&#13;
                              LSR_A();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x46: // LSR $??
&#13;
                              MR_ZP(); LSR(); MW_ZP();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x56: // LSR $??,X
&#13;
                              MR_ZX(); LSR(); MW_ZP();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x4E: // LSR $????
&#13;
                              MR_AB(); LSR(); MW_EA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x5E: // LSR $????,X
&#13;
                              MR_AX(); LSR(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0x09: // ORA #$??
&#13;
                              MR_IM(); ORA();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x05: // ORA $??
&#13;
                              MR_ZP(); ORA();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0x15: // ORA $??,X
&#13;
                              MR_ZX(); ORA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x0D: // ORA $????
&#13;
                              MR_AB(); ORA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x1D: // ORA $????,X
&#13;
                              MR_AX(); ORA(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x19: // ORA $????,Y
&#13;
                              MR_AY(); ORA(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x01: // ORA ($??,X)
&#13;
                              MR_IX(); ORA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x11: // ORA ($??),Y
&#13;
                              MR_IY(); ORA(); CHECK_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x2A: // ROL A
&#13;
                              ROL_A();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x26: // ROL $??
&#13;
                              MR_ZP(); ROL(); MW_ZP();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x36: // ROL $??,X
&#13;
                              MR_ZX(); ROL(); MW_ZP();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x2E: // ROL $????
&#13;
                              MR_AB(); ROL(); MW_EA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x3E: // ROL $????,X
&#13;
                              MR_AX(); ROL(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0x6A: // ROR A
&#13;
                              ROR_A();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x66: // ROR $??
&#13;
                              MR_ZP(); ROR(); MW_ZP();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x76: // ROR $??,X
&#13;
                              MR_ZX(); ROR(); MW_ZP();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x6E: // ROR $????
&#13;
                              MR_AB(); ROR(); MW_EA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x7E: // ROR $????,X
&#13;
                              MR_AX(); ROR(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0xA9: // LDA #$??
&#13;
                              MR_IM(); LDA();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xA5: // LDA $??
&#13;
                              MR_ZP(); LDA();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0xB5: // LDA $??,X
&#13;
                              MR_ZX(); LDA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xAD: // LDA $????
&#13;
                              MR_AB(); LDA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xBD: // LDA $????,X
&#13;
                              MR_AX(); LDA(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xB9: // LDA $????,Y
&#13;
                              MR_AY(); LDA(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xA1: // LDA ($??,X)
&#13;
                              MR_IX(); LDA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0xB1: // LDA ($??),Y
&#13;
                              MR_IY(); LDA(); CHECK_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0xA2: // LDX #$??
&#13;
                              MR_IM(); LDX();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xA6: // LDX $??
&#13;
                              MR_ZP(); LDX();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0xB6: // LDX $??,Y
&#13;
                              MR_ZY(); LDX();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xAE: // LDX $????
&#13;
                              MR_AB(); LDX();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xBE: // LDX $????,Y
&#13;
                              MR_AY(); LDX(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xA0: // LDY #$??
&#13;
                              MR_IM(); LDY();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xA4: // LDY $??
&#13;
                              MR_ZP(); LDY();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0xB4: // LDY $??,X
&#13;
                              MR_ZX(); LDY();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xAC: // LDY $????
&#13;
                              MR_AB(); LDY();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xBC: // LDY $????,X
&#13;
                              MR_AX(); LDY(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x85: // STA $??
&#13;
                              EA_ZP(); STA(); MW_ZP();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0x95: // STA $??,X
&#13;
                              EA_ZX(); STA(); MW_ZP();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x8D: // STA $????
&#13;
                              EA_AB(); STA(); MW_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x9D: // STA $????,X
&#13;
                              EA_AX(); STA(); MW_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x99: // STA $????,Y
&#13;
                              EA_AY(); STA(); MW_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x81: // STA ($??,X)
&#13;
                              EA_IX(); STA(); MW_EA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x91: // STA ($??),Y
&#13;
                              EA_IY(); STA(); MW_EA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x86: // STX $??
&#13;
                              EA_ZP(); STX(); MW_ZP();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0x96: // STX $??,Y
&#13;
                              EA_ZY(); STX(); MW_ZP();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x8E: // STX $????
&#13;
                              EA_AB(); STX(); MW_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x84: // STY $??
&#13;
                              EA_ZP(); STY(); MW_ZP();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0x94: // STY $??,X
&#13;
                              EA_ZX(); STY(); MW_ZP();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x8C: // STY $????
&#13;
                              EA_AB(); STY(); MW_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xAA: // TAX
&#13;
                              TAX();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x8A: // TXA
&#13;
                              TXA();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xA8: // TAY
&#13;
                              TAY();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x98: // TYA
&#13;
                              TYA();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xBA: // TSX
&#13;
                              TSX();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x9A: // TXS
&#13;
                              TXS();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xC9: // CMP #$??
&#13;
                              MR_IM(); CMP_();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xC5: // CMP $??
&#13;
                              MR_ZP(); CMP_();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0xD5: // CMP $??,X
&#13;
                              MR_ZX(); CMP_();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xCD: // CMP $????
&#13;
                              MR_AB(); CMP_();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xDD: // CMP $????,X
&#13;
                              MR_AX(); CMP_(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xD9: // CMP $????,Y
&#13;
                              MR_AY(); CMP_(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xC1: // CMP ($??,X)
&#13;
                              MR_IX(); CMP_();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0xD1: // CMP ($??),Y
&#13;
                              MR_IY(); CMP_(); CHECK_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0xE0: // CPX #$??
&#13;
                              MR_IM(); CPX();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xE4: // CPX $??
&#13;
                              MR_ZP(); CPX();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0xEC: // CPX $????
&#13;
                              MR_AB(); CPX();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xC0: // CPY #$??
&#13;
                              MR_IM(); CPY();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xC4: // CPY $??
&#13;
                              MR_ZP(); CPY();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0xCC: // CPY $????
&#13;
                              MR_AB(); CPY();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x90: // BCC
&#13;
                              MR_IM(); BCC();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xB0: // BCS
&#13;
                              MR_IM(); BCS();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xF0: // BEQ
&#13;
                              MR_IM(); BEQ();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x30: // BMI
&#13;
                              MR_IM(); BMI();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xD0: // BNE
&#13;
                              MR_IM(); BNE();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x10: // BPL
&#13;
                              MR_IM(); BPL();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x50: // BVC
&#13;
                              MR_IM(); BVC();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x70: // BVS
&#13;
                              MR_IM(); BVS();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x4C: // JMP $????
&#13;
                              JMP();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0x6C: // JMP ($????)
&#13;
                              JMP_ID();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x20: // JSR
&#13;
                              JSR();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x40: // RTI
&#13;
                              RTI();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x60: // RTS
&#13;
                              RTS();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
      // フラグ制御系
&#13;
                        case      0x18: // CLC
&#13;
                              CLC();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xD8: // CLD
&#13;
                              CLD();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x58: // CLI
&#13;
                              CLI();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xB8: // CLV
&#13;
                              CLV();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x38: // SEC
&#13;
                              SEC();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xF8: // SED
&#13;
                              SED();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x78: // SEI
&#13;
                              SEI();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
      // スタック系
&#13;
                        case      0x48: // PHA
&#13;
                              PUSH( R.A );
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0x08: // PHP
&#13;
                              PUSH( R.P | B_FLAG );
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0x68: // PLA (N-----Z-)
&#13;
                              R.A = POP();
&#13;
                              SET_ZN_FLAG(R.A);
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x28: // PLP
&#13;
                              R.P = POP() | R_FLAG;
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
      // その他
&#13;
                        case      0x00: // BRK
&#13;
                              BRK();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0xEA: // NOP
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
      // 未公開命令群
&#13;
                        case      0x0B: // ANC #$??
&#13;
                        case      0x2B: // ANC #$??
&#13;
                              MR_IM(); ANC();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x8B: // ANE #$??
&#13;
                              MR_IM(); ANE();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x6B: // ARR #$??
&#13;
                              MR_IM(); ARR();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x4B: // ASR #$??
&#13;
                              MR_IM(); ASR();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xC7: // DCP $??
&#13;
                              MR_ZP(); DCP(); MW_ZP();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0xD7: // DCP $??,X
&#13;
                              MR_ZX(); DCP(); MW_ZP();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0xCF: // DCP $????
&#13;
                              MR_AB(); DCP(); MW_EA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0xDF: // DCP $????,X
&#13;
                              MR_AX(); DCP(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0xDB: // DCP $????,Y
&#13;
                              MR_AY(); DCP(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0xC3: // DCP ($??,X)
&#13;
                              MR_IX(); DCP(); MW_EA();
&#13;
                              ADD_CYCLE(8);
&#13;
                              break;
&#13;
                        case      0xD3: // DCP ($??),Y
&#13;
                              MR_IY(); DCP(); MW_EA();
&#13;
                              ADD_CYCLE(8);
&#13;
                              break;
&#13;
                        case      0xE7: // ISB $??
&#13;
                              MR_ZP(); ISB(); MW_ZP();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0xF7: // ISB $??,X
&#13;
                              MR_ZX(); ISB(); MW_ZP();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0xEF: // ISB $????
&#13;
                              MR_AB(); ISB(); MW_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0xFF: // ISB $????,X
&#13;
                              MR_AX(); ISB(); MW_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0xFB: // ISB $????,Y
&#13;
                              MR_AY(); ISB(); MW_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0xE3: // ISB ($??,X)
&#13;
                              MR_IX(); ISB(); MW_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0xF3: // ISB ($??),Y
&#13;
                              MR_IY(); ISB(); MW_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0xBB: // LAS $????,Y
&#13;
                              MR_AY(); LAS(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xA7: // LAX $??
&#13;
                              MR_ZP(); LAX();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0xB7: // LAX $??,Y
&#13;
                              MR_ZY(); LAX();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xAF: // LAX $????
&#13;
                              MR_AB(); LAX();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xBF: // LAX $????,Y
&#13;
                              MR_AY(); LAX(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xA3: // LAX ($??,X)
&#13;
                              MR_IX(); LAX();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0xB3: // LAX ($??),Y
&#13;
                              MR_IY(); LAX(); CHECK_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0xAB: // LXA #$??
&#13;
                              MR_IM(); LXA();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x27: // RLA $??
&#13;
                              MR_ZP(); RLA(); MW_ZP();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x37: // RLA $??,X
&#13;
                              MR_ZX(); RLA(); MW_ZP();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x2F: // RLA $????
&#13;
                              MR_AB(); RLA(); MW_EA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x3F: // RLA $????,X
&#13;
                              MR_AX(); RLA(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0x3B: // RLA $????,Y
&#13;
                              MR_AY(); RLA(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0x23: // RLA ($??,X)
&#13;
                              MR_IX(); RLA(); MW_EA();
&#13;
                              ADD_CYCLE(8);
&#13;
                              break;
&#13;
                        case      0x33: // RLA ($??),Y
&#13;
                              MR_IY(); RLA(); MW_EA();
&#13;
                              ADD_CYCLE(8);
&#13;
                              break;
&#13;
                        case      0x67: // RRA $??
&#13;
                              MR_ZP(); RRA(); MW_ZP();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x77: // RRA $??,X
&#13;
                              MR_ZX(); RRA(); MW_ZP();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x6F: // RRA $????
&#13;
                              MR_AB(); RRA(); MW_EA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x7F: // RRA $????,X
&#13;
                              MR_AX(); RRA(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0x7B: // RRA $????,Y
&#13;
                              MR_AY(); RRA(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0x63: // RRA ($??,X)
&#13;
                              MR_IX(); RRA(); MW_EA();
&#13;
                              ADD_CYCLE(8);
&#13;
                              break;
&#13;
                        case      0x73: // RRA ($??),Y
&#13;
                              MR_IY(); RRA(); MW_EA();
&#13;
                              ADD_CYCLE(8);
&#13;
                              break;
&#13;
                        case      0x87: // SAX $??
&#13;
                              MR_ZP(); SAX(); MW_ZP();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0x97: // SAX $??,Y
&#13;
                              MR_ZY(); SAX(); MW_ZP();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x8F: // SAX $????
&#13;
                              MR_AB(); SAX(); MW_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x83: // SAX ($??,X)
&#13;
                              MR_IX(); SAX(); MW_EA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0xCB: // SBX #$??
&#13;
                              MR_IM(); SBX();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x9F: // SHA $????,Y
&#13;
                              MR_AY(); SHA(); MW_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x93: // SHA ($??),Y
&#13;
                              MR_IY(); SHA(); MW_EA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x9B: // SHS $????,Y
&#13;
                              MR_AY(); SHS(); MW_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x9E: // SHX $????,Y
&#13;
                              MR_AY(); SHX(); MW_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x9C: // SHY $????,X
&#13;
                              MR_AX(); SHY(); MW_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x07: // SLO $??
&#13;
                              MR_ZP(); SLO(); MW_ZP();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x17: // SLO $??,X
&#13;
                              MR_ZX(); SLO(); MW_ZP();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x0F: // SLO $????
&#13;
                              MR_AB(); SLO(); MW_EA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x1F: // SLO $????,X
&#13;
                              MR_AX(); SLO(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0x1B: // SLO $????,Y
&#13;
                              MR_AY(); SLO(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0x03: // SLO ($??,X)
&#13;
                              MR_IX(); SLO(); MW_EA();
&#13;
                              ADD_CYCLE(8);
&#13;
                              break;
&#13;
                        case      0x13: // SLO ($??),Y
&#13;
                              MR_IY(); SLO(); MW_EA();
&#13;
                              ADD_CYCLE(8);
&#13;
                              break;
&#13;
                        case      0x47: // SRE $??
&#13;
                              MR_ZP(); SRE(); MW_ZP();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x57: // SRE $??,X
&#13;
                              MR_ZX(); SRE(); MW_ZP();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x4F: // SRE $????
&#13;
                              MR_AB(); SRE(); MW_EA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x5F: // SRE $????,X
&#13;
                              MR_AX(); SRE(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0x5B: // SRE $????,Y
&#13;
                              MR_AY(); SRE(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0x43: // SRE ($??,X)
&#13;
                              MR_IX(); SRE(); MW_EA();
&#13;
                              ADD_CYCLE(8);
&#13;
                              break;
&#13;
                        case      0x53: // SRE ($??),Y
&#13;
                              MR_IY(); SRE(); MW_EA();
&#13;
                              ADD_CYCLE(8);
&#13;
                              break;
&#13;
                        case      0xEB: // SBC #$?? (Unofficial)
&#13;
                              MR_IM(); SBC();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x1A: // NOP (Unofficial)
&#13;
                        case      0x3A: // NOP (Unofficial)
&#13;
                        case      0x5A: // NOP (Unofficial)
&#13;
                        case      0x7A: // NOP (Unofficial)
&#13;
                        case      0xDA: // NOP (Unofficial)
&#13;
                        case      0xFA: // NOP (Unofficial)
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x80: // DOP (CYCLES 2)
&#13;
                        case      0x82: // DOP (CYCLES 2)
&#13;
                        case      0x89: // DOP (CYCLES 2)
&#13;
                        case      0xC2: // DOP (CYCLES 2)
&#13;
                        case      0xE2: // DOP (CYCLES 2)
&#13;
                              R.PC++;
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x04: // DOP (CYCLES 3)
&#13;
                        case      0x44: // DOP (CYCLES 3)
&#13;
                        case      0x64: // DOP (CYCLES 3)
&#13;
                              R.PC++;
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0x14: // DOP (CYCLES 4)
&#13;
                        case      0x34: // DOP (CYCLES 4)
&#13;
                        case      0x54: // DOP (CYCLES 4)
&#13;
                        case      0x74: // DOP (CYCLES 4)
&#13;
                        case      0xD4: // DOP (CYCLES 4)
&#13;
                        case      0xF4: // DOP (CYCLES 4)
&#13;
                              R.PC++;
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x0C: // TOP
&#13;
                        case      0x1C: // TOP
&#13;
                        case      0x3C: // TOP
&#13;
                        case      0x5C: // TOP
&#13;
                        case      0x7C: // TOP
&#13;
                        case      0xDC: // TOP
&#13;
                        case      0xFC: // TOP
&#13;
                              R.PC+=2;
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x02:/* JAM */
&#13;
                        case      0x12:/* JAM */
&#13;
                        case      0x22:/* JAM */
&#13;
                        case      0x32:/* JAM */
&#13;
                        case      0x42:/* JAM */
&#13;
                        case      0x52:/* JAM */
&#13;
                        case      0x62:/* JAM */
&#13;
                        case      0x72:/* JAM */
&#13;
                        case      0x92:/* JAM */
&#13;
                        case      0xB2:/* JAM */
&#13;
                        case      0xD2:/* JAM */
&#13;
                        case      0xF2:/* JAM */
&#13;
                        default:
&#13;
                              if( !Config.emulator.bIllegalOp ) {
&#13;
                                        throw      CApp::GetErrorString( IDS_ERROR_ILLEGALOPCODE );
&#13;
                                        goto      _execute_exit;
&#13;
                              } else {
&#13;
                                        R.PC--;
&#13;
                                        ADD_CYCLE(4);
&#13;
                              }
&#13;
                              break;
&#13;
//                        default:
&#13;
//                              __assume(0);
&#13;
                }
&#13;
                if( nmi_request ) {
&#13;
                        _NMI();
&#13;
                } else
&#13;
                if( irq_request ) {
&#13;
                        _IRQ();
&#13;
                }
&#13;
                request_cycles -= exec_cycles;
&#13;
                TOTAL_cycles += exec_cycles;
&#13;
                // クロック同期処理
&#13;
                mapper-&gt;Clock( exec_cycles );
&#13;
#if      DPCM_SYNCCLOCK
&#13;
                apu-&gt;SyncDPCM( exec_cycles );
&#13;
#endif
&#13;
                if( bClockProcess ) {
&#13;
                        nes-&gt;Clock( exec_cycles );
&#13;
                }
&#13;
//                nes-&gt;Clock( exec_cycles );
&#13;
      }
&#13;
_execute_exit:
&#13;
#if      !DPCM_SYNCCLOCK
&#13;
      apu-&gt;SyncDPCM( TOTAL_cycles - OLD_cycles );
&#13;
#endif
&#13;
      return      TOTAL_cycles - OLD_cycles;
&#13;
}</description>
      <content:encoded><![CDATA[<p><b>Kym1908: </b><br>
<span>你管这叫最简单？</span><br>
</p><p><b>jdd46820: </b><br>
<span>泥潭果真人均程序员啊</span><br>
</p><p><b>SICP: </b><br>
<span>jctc 发表于 2019-7-4 14:26</span><br>
<span>我草</span><br>
<span>这写的也太难了吧</span><br>
<span>完全看不懂</span><br>
</p><p><b>苇原雪道: </b><br>
<span>嵌入式单片机编程在整个码农鄙视链最底端，不建议入行。。。</span><br>
</p><p><b>Jobtown: </b><br>
<span>#include<iostream></span><br>
<span>using namespace std;</span><br>
<span>int main()</span><br>
<span>{</span><br>
<span>cout<<"hello world"<<endl;</span><br>
<span>return 0;</span><br>
<span>}</span><br>
<span>大学计算机语言课程请</span><br>
</p><p><b>nvis: </b><br>
<span>名字都写出来了，以为没人没玩过VirtuaNES吗</span><br>
</p><p><b>j5g27: </b><br>
<span>发帖记录散发着一股子浓浓的巨魔气息</span><br>
</p><p><b>yigua: </b><br>
<span>Lunamos 发表于 2019-7-4 14:31</span><br>
<span>用C写6502挺简单的，你看着复杂，其实理解了6502的工作原理以后会觉得这些代码都是非常直观的。</span><br>
<span>比较难的 ...</span><br>
<span>首先不要用程序员思维来理解hdl</span><br>
<span>其次fsdb爽的一比</span><br>
</p><p><b>yigua: </b><br>
<span>苇原雪道 发表于 2019-7-6 20:29</span><br>
<span>嵌入式单片机编程在整个码农鄙视链最底端，不建议入行。。。</span><br>
<span>是吗？当初大学课程用的汇编来写单片机程序.......</span><br>
</p><p><b>硬盘删干净了: </b><br>
<span>这个时候不应该是说“xxx是最美丽的语言”？</span><br>
</p><p><b>硬盘删干净了: </b><br>
<span>这个时候不应该是说“xxx是最美丽的语言”？</span><br>
</p><p><b>laotoutou: </b><br>
<span>导入到ide里，看到不懂得按f1。</span><br>
</p><p><b>アーシェス: </b><br>
<span> 本帖最后由 アーシェス 于 2019-7-6 20:53 编辑 </span><br>
<span>讨论编程的时候还是要区分编程对象和编程手段吧</span><br>
<span>Web 操作的是 dom 和网络请求，单片机编程操作的是寄存器和 IO 端口</span><br>
<span>手段原始的时候都可以很原始，复杂起来也都可以很复杂</span><br>
<span>因为硬件条件和历史的原因表达能力会有些差距，但是编程思维多少是互通的</span><br>
<span>格差更多的是来自所属领域的市场热度的区别</span><br>
<span>当然 Verilog 那鸡儿语法完全是不作为，不过现在挂靠其他编程语言的替换品也有很多了</span><br>
</p><p><b>车欠: </b><br>
<span>洗刷刷 发表于 2019-7-4 15:08</span><br>
<span>原来如此，不需要多线程，能保证频率固定的话，的确能起到该起的作用。不过写这东西一定很痛苦... ...</span><br>
<span>确实是痛苦。一个延迟函数是否符合预期，必须要上示波器/逻辑分析仪测量。</span><br>
</p><p><b>kumh: </b><br>
<span>hunterkiller 发表于 2019-7-4 14:22</span><br>
<span>这不是挺好的么....</span><br>
<span>又不是p=p->next?p->next:p这种混乱邪恶的代码</span><br>
<span>简单明了，不邪恶。</span><br>
</p><p><b>muckenberger2: </b><br>
<span>这是照着data sheet写的吧</span><br>
</p><p><b>WIZARDMK2: </b><br>
<span>要学单片机整个51啊ARM啥的不好吗</span><br>
</p><p><b>Litccc: </b><br>
<span>说不定能手工焊出来</span><br>
</p><p><b>phorcys02: </b><br>
<span>你这生写6502模拟代码过时了</span><br>
<span>现在流行用 llvm，写起来比你这个清爽多了....</span><br>
<span>毕竟6502 加上PC总共5个寄存器</span><br>
<span>操作码也就几十个，实现起来easy</span><br>
</p>]]></content:encoded>
      <guid isPermaLink="false">1844205[50-100]</guid>
    </item>
    <item>
      <title>解释下"找别人写的最简单的C/C++代码来看,直接放弃编程梦想"[0-50]</title>
      <link>https://bbs.saraba1st.com/2b/thread-1844205-1-1.html</link>
      <description>找了一个别人写的最简单的C/C++代码来看，直接放弃编程梦想&#13;
 本帖最后由 CAMUS.net 于 2019-7-4 13:03 编辑 

//////////////////////////////////////////////////////////////////////////
&#13;
//                                                                      //
&#13;
//      6502 CPU core                                                   //
&#13;
//                                                         Norix      //
&#13;
//                                             written   2001/02/22 //
&#13;
//                                             last modify ----/--/-- //
&#13;
//////////////////////////////////////////////////////////////////////////
&#13;
#ifndef      __CPU_INCLUDED__
&#13;
#define      __CPU_INCLUDED__
&#13;
#include "typedef.h"
&#13;
#include "macro.h"
&#13;
class      NES;
&#13;
class      APU;
&#13;
class      Mapper;
&#13;
// 6502 status flags
&#13;
#define      C_FLAG                0x01                // 1: Carry
&#13;
#define      Z_FLAG                0x02                // 1: Zero
&#13;
#define      I_FLAG                0x04                // 1: Irq disabled
&#13;
#define      D_FLAG                0x08                // 1: Decimal mode flag (NES unused)
&#13;
#define      B_FLAG                0x10                // 1: Break
&#13;
#define      R_FLAG                0x20                // 1: Reserved (Always 1)
&#13;
#define      V_FLAG                0x40                // 1: Overflow
&#13;
#define      N_FLAG                0x80                // 1: Negative
&#13;
// Interrupt
&#13;
#define      NMI_FLAG      0x01
&#13;
#define      IRQ_FLAG      0x02
&#13;
#define      IRQ_FRAMEIRQ      0x04
&#13;
#define      IRQ_DPCM      0x08
&#13;
#define      IRQ_MAPPER      0x10
&#13;
#define      IRQ_MAPPER2      0x20
&#13;
#define      IRQ_TRIGGER      0x40                // one shot(旧IRQ())
&#13;
#define      IRQ_TRIGGER2      0x80                // one shot(旧IRQ_NotPending())
&#13;
#define      IRQ_MASK      (~(NMI_FLAG|IRQ_FLAG))
&#13;
// Vector
&#13;
#define      NMI_VECTOR      0xFFFA
&#13;
#define      RES_VECTOR      0xFFFC
&#13;
#define      IRQ_VECTOR      0xFFFE
&#13;
// 6502 context
&#13;
typedef      struct      {
&#13;
      WORD      PC;      /* Program counter   */
&#13;
      BYTE      A;      /* CPU registers   */
&#13;
      BYTE      P;
&#13;
      BYTE      X;
&#13;
      BYTE      Y;
&#13;
      BYTE      S;
&#13;
      BYTE      INT_pending;      // 割り込みペンディングフラグ
&#13;
} R6502;
&#13;
class      CPU
&#13;
{
&#13;
public:
&#13;
      CPU( NES* parent );
&#13;
      virtual      ~CPU();
&#13;
      BYTE      RD6502( WORD addr );
&#13;
      void      WR6502( WORD addr, BYTE data );
&#13;
      WORD      RD6502W( WORD addr );
&#13;
      void      Reset();
&#13;
      void      NMI();
&#13;
      void      SetIRQ( BYTE mask );
&#13;
      void      ClrIRQ( BYTE mask );
&#13;
      void      DMA( INT cycles );
&#13;
      INT      EXEC( INT request_cycles );
&#13;
      INT      GetDmaCycles();
&#13;
      void      SetDmaCycles( INT cycles );
&#13;
      INT      GetTotalCycles();
&#13;
      void      SetTotalCycles( INT cycles );
&#13;
      void      SetContext( R6502 r )      { R = r; }
&#13;
      void      GetContext( R6502&amp; r )      { r = R; }
&#13;
      void      SetClockProcess( BOOL bEnable ) { m_bClockProcess = bEnable; }
&#13;
protected:
&#13;
      NES*      nes;
&#13;
      APU*      apu;
&#13;
      Mapper*      mapper;
&#13;
      R6502      R;
&#13;
      INT      TOTAL_cycles;      // CPUトータルサイクル数
&#13;
      INT      DMA_cycles;      // DMAサイクル数
&#13;
      // PTR
&#13;
      LPBYTE      STACK;
&#13;
      // Zero &amp; Negative table
&#13;
      BYTE      ZN_Table;
&#13;
      // Clock process
&#13;
      BOOL      m_bClockProcess;
&#13;
private:
&#13;
};
&#13;
#endif      // !__CPU_INCLUDED__
&#13;
/*----------------------------------------------------------------------*/
&#13;
/*                                                                      */
&#13;
/*      6502 CPU Core v0.00                                             */
&#13;
/*                                                         Norix      */
&#13;
/*                                             written   2000/12/23 */
&#13;
/*                                             last modify ----/--/-- */
&#13;
/*----------------------------------------------------------------------*/
&#13;
/*--------------[ INCLUDE               ]-------------------------------*/
&#13;
#define      WIN32_LEAN_AND_MEAN
&#13;
#include &lt;windows.h&gt;
&#13;
#include "VirtuaNESres.h"
&#13;
#include "typedef.h"
&#13;
#include "macro.h"
&#13;
#include "DebugOut.h"
&#13;
#include "App.h"
&#13;
#include "Config.h"
&#13;
#include "nes.h"
&#13;
#include "mmu.h"
&#13;
#include "cpu.h"
&#13;
#include "ppu.h"
&#13;
#include "apu.h"
&#13;
#include "rom.h"
&#13;
#include "mapper.h"
&#13;
/*--------------[ DEFINE                ]-------------------------------*/
&#13;
#define      DPCM_SYNCCLOCK      FALSE
&#13;
/*--------------[ EXTERNAL PROGRAM      ]-------------------------------*/
&#13;
/*--------------[ EXTERNAL WORK         ]-------------------------------*/
&#13;
/*--------------[ WORK                  ]-------------------------------*/
&#13;
/*--------------[ CONST               ]-------------------------------*/
&#13;
/*--------------[ PROTOTYPE             ]-------------------------------*/
&#13;
/*--------------[ PROGRAM               ]-------------------------------*/
&#13;
// オペコード
&#13;
//#define      OP6502(A)      RD6502((A))
&#13;
//#define      OP6502W(A)      RD6502W((A))
&#13;
// ゼロページリード
&#13;
#define      ZPRD(A)                (RAM[(BYTE)(A)])
&#13;
//#define      ZPRDW(A)      (*((LPWORD)&amp;RAM[(BYTE)(A)]))
&#13;
#define      ZPRDW(A)      ((WORD)RAM[(BYTE)(A)]+((WORD)RAM[(BYTE)((A)+1)]&lt;&lt;8))
&#13;
#define      ZPWR(A,V)      { RAM[(BYTE)(A)]=(V); }
&#13;
#define      ZPWRW(A,V)      { *((LPWORD)&amp;RAM[(BYTE)(A)])=(WORD)(V); }
&#13;
// サイクルカウンタ
&#13;
#define      ADD_CYCLE(V)      { exec_cycles += (V); }
&#13;
//#define      ADD_CYCLE(V)      {}
&#13;
// EFFECTIVE ADDRESSページ境界超えチェック
&#13;
#define      CHECK_EA()      { if( (ET&amp;0xFF00) != (EA&amp;0xFF00) ) ADD_CYCLE(1); }
&#13;
//#define      CHECK_EA()      { if( (R.PC&amp;0xFF00) != (EA&amp;0xFF00) ) ADD_CYCLE(1); }
&#13;
//#define      CHECK_EA()      {}
&#13;
// フラグ操作
&#13;
// ゼロ／ネガティブフラグのチェックと設定
&#13;
#define      SET_ZN_FLAG(A)      { R.P &amp;= ~(Z_FLAG|N_FLAG); R.P |= ZN_Table[(BYTE)(A)]; }
&#13;
// フラグセット
&#13;
#define      SET_FLAG(V)      { R.P |=(V); }
&#13;
// フラグクリア
&#13;
#define      CLR_FLAG(V)      { R.P &amp;= ~(V); }
&#13;
// フラグテスト＆セット／クリア
&#13;
#define      TST_FLAG(F,V)      { R.P &amp;= ~(V); if((F)) R.P |= (V); }
&#13;
// フラグチェック
&#13;
#define      CHK_FLAG(V)      (R.P&amp;(V))
&#13;
// WT .... WORD TEMP
&#13;
// EA .... EFFECTIVE ADDRESS
&#13;
// ET .... EFFECTIVE ADDRESS TEMP
&#13;
// DT .... DATA
&#13;
#define      MR_IM()      {                \
&#13;
      DT = OP6502( R.PC++ );      \
&#13;
}
&#13;
#define      MR_ZP()      {                \
&#13;
      EA = OP6502( R.PC++ );      \
&#13;
      DT = ZPRD( EA );      \
&#13;
}
&#13;
#define      MR_ZX()      {                \
&#13;
      DT = OP6502( R.PC++ );      \
&#13;
      EA = (BYTE)(DT + R.X);      \
&#13;
      DT = ZPRD( EA );      \
&#13;
}
&#13;
#define      MR_ZY()      {                \
&#13;
      DT = OP6502( R.PC++ );      \
&#13;
      EA = (BYTE)(DT + R.Y);      \
&#13;
      DT = ZPRD( EA );      \
&#13;
}
&#13;
#define      MR_AB()      {                \
&#13;
      EA = OP6502W( R.PC );      \
&#13;
      R.PC += 2;                \
&#13;
      DT = RD6502( EA );      \
&#13;
}
&#13;
#define      MR_AX()      {                \
&#13;
      ET = OP6502W( R.PC );      \
&#13;
      R.PC += 2;                \
&#13;
      EA = ET + R.X;                \
&#13;
      DT = RD6502( EA );      \
&#13;
}
&#13;
#define      MR_AY()      {                \
&#13;
      ET = OP6502W( R.PC );      \
&#13;
      R.PC += 2;                \
&#13;
      EA = ET + R.Y;                \
&#13;
      DT = RD6502( EA );      \
&#13;
}
&#13;
#define      MR_IX()      {                \
&#13;
      DT = OP6502( R.PC++ );      \
&#13;
      EA = ZPRDW( DT + R.X );      \
&#13;
      DT = RD6502( EA );      \
&#13;
}
&#13;
#define      MR_IY()      {                \
&#13;
      DT = OP6502( R.PC++ );      \
&#13;
      ET = ZPRDW( DT );      \
&#13;
      EA = ET + R.Y;                \
&#13;
      DT = RD6502( EA );      \
&#13;
}
&#13;
// EFFECTIVE ADDRESS
&#13;
#define      EA_ZP()      {                \
&#13;
      EA = OP6502( R.PC++ );      \
&#13;
}
&#13;
#define      EA_ZX()      {                \
&#13;
      DT = OP6502( R.PC++ );      \
&#13;
      EA = (BYTE)(DT + R.X);      \
&#13;
}
&#13;
#define      EA_ZY()      {                \
&#13;
      DT = OP6502( R.PC++ );      \
&#13;
      EA = (BYTE)(DT + R.Y);      \
&#13;
}
&#13;
#define      EA_AB()      {                \
&#13;
      EA = OP6502W( R.PC );      \
&#13;
      R.PC += 2;                \
&#13;
}
&#13;
#define      EA_AX()      {                \
&#13;
      ET = OP6502W( R.PC );      \
&#13;
      R.PC += 2;                \
&#13;
      EA = ET + R.X;                \
&#13;
}
&#13;
#define      EA_AY()      {                \
&#13;
      ET = OP6502W( R.PC );      \
&#13;
      R.PC += 2;                \
&#13;
      EA = ET + R.Y;                \
&#13;
}
&#13;
#define      EA_IX()      {                \
&#13;
      DT = OP6502( R.PC++ );      \
&#13;
      EA = ZPRDW( DT + R.X );      \
&#13;
}
&#13;
#define      EA_IY()      {                \
&#13;
      DT = OP6502( R.PC++ );      \
&#13;
      ET = ZPRDW( DT );      \
&#13;
      EA = ET + (WORD)R.Y;      \
&#13;
}
&#13;
// メモリライト
&#13;
#define      MW_ZP()                ZPWR(EA,DT)
&#13;
#define      MW_EA()                WR6502(EA,DT)
&#13;
// STACK操作
&#13;
#define      PUSH(V)                { STACK[(R.S--)&amp;0xFF]=(V); }
&#13;
#define      POP()                STACK[(++R.S)&amp;0xFF]
&#13;
// 算術演算系
&#13;
/* ADC (NV----ZC) */
&#13;
#define      ADC() {                                                      \
&#13;
      WT = R.A+DT+(R.P&amp;C_FLAG);                              \
&#13;
      TST_FLAG( WT &gt; 0xFF, C_FLAG );                              \
&#13;
      TST_FLAG( ((~(R.A^DT))&amp;(R.A^WT)&amp;0x80), V_FLAG );      \
&#13;
      R.A = (BYTE)WT;                                                \
&#13;
      SET_ZN_FLAG(R.A);                                        \
&#13;
}
&#13;
/* SBC (NV----ZC) */
&#13;
#define      SBC() {                                                \
&#13;
      WT = R.A-DT-(~R.P&amp;C_FLAG);                        \
&#13;
      TST_FLAG( ((R.A^DT) &amp; (R.A^WT)&amp;0x80), V_FLAG );      \
&#13;
      TST_FLAG( WT &lt; 0x100, C_FLAG );                        \
&#13;
      R.A = (BYTE)WT;                                        \
&#13;
      SET_ZN_FLAG(R.A);                              \
&#13;
}
&#13;
/* INC (N-----Z-) */
&#13;
#define      INC() {                        \
&#13;
      DT++;                        \
&#13;
      SET_ZN_FLAG(DT);      \
&#13;
}
&#13;
/* INX (N-----Z-) */
&#13;
#define      INX() {                        \
&#13;
      R.X++;                        \
&#13;
      SET_ZN_FLAG(R.X);      \
&#13;
}
&#13;
/* INY (N-----Z-) */
&#13;
#define      INY() {                        \
&#13;
      R.Y++;                        \
&#13;
      SET_ZN_FLAG(R.Y);      \
&#13;
}
&#13;
/* DEC (N-----Z-) */
&#13;
#define      DEC() {                        \
&#13;
      DT--;                        \
&#13;
      SET_ZN_FLAG(DT);      \
&#13;
}
&#13;
/* DEX (N-----Z-) */
&#13;
#define      DEX() {                        \
&#13;
      R.X--;                        \
&#13;
      SET_ZN_FLAG(R.X);      \
&#13;
}
&#13;
/* DEY (N-----Z-) */
&#13;
#define      DEY() {                        \
&#13;
      R.Y--;                        \
&#13;
      SET_ZN_FLAG(R.Y);      \
&#13;
}
&#13;
// 論理演算系
&#13;
/* AND (N-----Z-) */
&#13;
#define      AND() {                        \
&#13;
      R.A &amp;= DT;                \
&#13;
      SET_ZN_FLAG(R.A);      \
&#13;
}
&#13;
/* ORA (N-----Z-) */
&#13;
#define      ORA() {                        \
&#13;
      R.A |= DT;                \
&#13;
      SET_ZN_FLAG(R.A);      \
&#13;
}
&#13;
/* EOR (N-----Z-) */
&#13;
#define      EOR() {                        \
&#13;
      R.A ^= DT;                \
&#13;
      SET_ZN_FLAG(R.A);      \
&#13;
}
&#13;
/* ASL_A (N-----ZC) */
&#13;
#define      ASL_A() {                        \
&#13;
      TST_FLAG( R.A&amp;0x80, C_FLAG );      \
&#13;
      R.A &lt;&lt;= 1;                        \
&#13;
      SET_ZN_FLAG(R.A);                \
&#13;
}
&#13;
/* ASL (N-----ZC) */
&#13;
#define      ASL() {                              \
&#13;
      TST_FLAG( DT&amp;0x80, C_FLAG );      \
&#13;
      DT &lt;&lt;= 1;                        \
&#13;
      SET_ZN_FLAG(DT);                \
&#13;
}
&#13;
/* LSR_A (N-----ZC) */
&#13;
#define      LSR_A() {                        \
&#13;
      TST_FLAG( R.A&amp;0x01, C_FLAG );      \
&#13;
      R.A &gt;&gt;= 1;                        \
&#13;
      SET_ZN_FLAG(R.A);                \
&#13;
}
&#13;
/* LSR (N-----ZC) */
&#13;
#define      LSR() {                              \
&#13;
      TST_FLAG( DT&amp;0x01, C_FLAG );      \
&#13;
      DT &gt;&gt;= 1;                        \
&#13;
      SET_ZN_FLAG(DT);                \
&#13;
}
&#13;
/* ROL_A (N-----ZC) */
&#13;
#define      ROL_A() {                              \
&#13;
      if( R.P &amp; C_FLAG ) {                        \
&#13;
                TST_FLAG(R.A&amp;0x80,C_FLAG);      \
&#13;
                R.A = (R.A&lt;&lt;1)|0x01;                \
&#13;
      } else {                              \
&#13;
                TST_FLAG(R.A&amp;0x80,C_FLAG);      \
&#13;
                R.A &lt;&lt;= 1;                        \
&#13;
      }                                        \
&#13;
      SET_ZN_FLAG(R.A);                        \
&#13;
}
&#13;
/* ROL (N-----ZC) */
&#13;
#define      ROL() {                                        \
&#13;
      if( R.P &amp; C_FLAG ) {                        \
&#13;
                TST_FLAG(DT&amp;0x80,C_FLAG);      \
&#13;
                DT = (DT&lt;&lt;1)|0x01;                \
&#13;
      } else {                              \
&#13;
                TST_FLAG(DT&amp;0x80,C_FLAG);      \
&#13;
                DT &lt;&lt;= 1;                        \
&#13;
      }                                        \
&#13;
      SET_ZN_FLAG(DT);                        \
&#13;
}
&#13;
/* ROR_A (N-----ZC) */
&#13;
#define      ROR_A() {                              \
&#13;
      if( R.P &amp; C_FLAG ) {                        \
&#13;
                TST_FLAG(R.A&amp;0x01,C_FLAG);      \
&#13;
                R.A = (R.A&gt;&gt;1)|0x80;                \
&#13;
      } else {                              \
&#13;
                TST_FLAG(R.A&amp;0x01,C_FLAG);      \
&#13;
                R.A &gt;&gt;= 1;                        \
&#13;
      }                                        \
&#13;
      SET_ZN_FLAG(R.A);                        \
&#13;
}
&#13;
/* ROR (N-----ZC) */
&#13;
#define      ROR() {                                        \
&#13;
      if( R.P &amp; C_FLAG ) {                        \
&#13;
                TST_FLAG(DT&amp;0x01,C_FLAG);      \
&#13;
                DT = (DT&gt;&gt;1)|0x80;                \
&#13;
      } else {                              \
&#13;
                TST_FLAG(DT&amp;0x01,C_FLAG);      \
&#13;
                DT &gt;&gt;= 1;                        \
&#13;
      }                                        \
&#13;
      SET_ZN_FLAG(DT);                        \
&#13;
}
&#13;
/* BIT (NV----Z-) */
&#13;
#define      BIT() {                                        \
&#13;
      TST_FLAG( (DT&amp;R.A)==0, Z_FLAG );      \
&#13;
      TST_FLAG( DT&amp;0x80, N_FLAG );                \
&#13;
      TST_FLAG( DT&amp;0x40, V_FLAG );                \
&#13;
}
&#13;
// ロード／ストア系
&#13;
/* LDA (N-----Z-) */
&#13;
#define      LDA()      { R.A = DT; SET_ZN_FLAG(R.A); }
&#13;
/* LDX (N-----Z-) */
&#13;
#define      LDX()      { R.X = DT; SET_ZN_FLAG(R.X); }
&#13;
/* LDY (N-----Z-) */
&#13;
#define      LDY()      { R.Y = DT; SET_ZN_FLAG(R.Y); }
&#13;
/* STA (--------) */
&#13;
#define      STA()      { DT = R.A; }
&#13;
/* STX (--------) */
&#13;
#define      STX()      { DT = R.X; }
&#13;
/* STY (--------) */
&#13;
#define      STY()      { DT = R.Y; }
&#13;
/* TAX (N-----Z-) */
&#13;
#define      TAX()      { R.X = R.A; SET_ZN_FLAG(R.X); }
&#13;
/* TXA (N-----Z-) */
&#13;
#define      TXA()      { R.A = R.X; SET_ZN_FLAG(R.A); }
&#13;
/* TAY (N-----Z-) */
&#13;
#define      TAY()      { R.Y = R.A; SET_ZN_FLAG(R.Y); }
&#13;
/* TYA (N-----Z-) */
&#13;
#define      TYA()      { R.A = R.Y; SET_ZN_FLAG(R.A); }
&#13;
/* TSX (N-----Z-) */
&#13;
#define      TSX()      { R.X = R.S; SET_ZN_FLAG(R.X); }
&#13;
/* TXS (--------) */
&#13;
#define      TXS()      { R.S = R.X; }
&#13;
// 比較系
&#13;
/* CMP (N-----ZC) */
&#13;
#define      CMP_() {                              \
&#13;
      WT = (WORD)R.A - (WORD)DT;                \
&#13;
      TST_FLAG( (WT&amp;0x8000)==0, C_FLAG );      \
&#13;
      SET_ZN_FLAG( (BYTE)WT );                \
&#13;
}
&#13;
/* CPX (N-----ZC) */
&#13;
#define      CPX() {                                        \
&#13;
      WT = (WORD)R.X - (WORD)DT;                \
&#13;
      TST_FLAG( (WT&amp;0x8000)==0, C_FLAG );      \
&#13;
      SET_ZN_FLAG( (BYTE)WT );                \
&#13;
}
&#13;
/* CPY (N-----ZC) */
&#13;
#define      CPY() {                                        \
&#13;
      WT = (WORD)R.Y - (WORD)DT;                \
&#13;
      TST_FLAG( (WT&amp;0x8000)==0, C_FLAG );      \
&#13;
      SET_ZN_FLAG( (BYTE)WT );                \
&#13;
}
&#13;
// ジャンプ／リターン系
&#13;
#if      1
&#13;
#define      JMP_ID() {                              \
&#13;
      WT = OP6502W(R.PC);                        \
&#13;
      EA = RD6502(WT);                        \
&#13;
      WT = (WT&amp;0xFF00)|((WT+1)&amp;0x00FF);      \
&#13;
      R.PC = EA+RD6502(WT)*0x100;                \
&#13;
}
&#13;
#else
&#13;
#define      JMP_ID() {                \
&#13;
      ET = OP6502W(R.PC);      \
&#13;
      EA = RD6502W(ET);      \
&#13;
      R.PC = EA;                \
&#13;
}
&#13;
#endif
&#13;
#define      JMP() {                        \
&#13;
      R.PC = OP6502W( R.PC );      \
&#13;
}
&#13;
#define      JSR() {                        \
&#13;
      EA = OP6502W( R.PC );      \
&#13;
      R.PC++;                        \
&#13;
      PUSH( R.PC&gt;&gt;8 );      \
&#13;
      PUSH( R.PC&amp;0xFF );      \
&#13;
      R.PC = EA;                \
&#13;
}
&#13;
#define      RTS() {                        \
&#13;
      R.PC= POP();                \
&#13;
      R.PC |= POP()*0x0100;      \
&#13;
      R.PC++;                        \
&#13;
}
&#13;
#define      RTI() {                        \
&#13;
      R.P   = POP() | R_FLAG;      \
&#13;
      R.PC= POP();                \
&#13;
      R.PC |= POP()*0x0100;      \
&#13;
}
&#13;
#define      _NMI() {                        \
&#13;
      PUSH( R.PC&gt;&gt;8 );                \
&#13;
      PUSH( R.PC&amp;0xFF );                \
&#13;
      CLR_FLAG( B_FLAG );                \
&#13;
      PUSH( R.P );                        \
&#13;
      SET_FLAG( I_FLAG );                \
&#13;
      R.PC = RD6502W(NMI_VECTOR);      \
&#13;
      exec_cycles += 7;                \
&#13;
}
&#13;
#define      _IRQ() {                        \
&#13;
      PUSH( R.PC&gt;&gt;8 );                \
&#13;
      PUSH( R.PC&amp;0xFF );                \
&#13;
      CLR_FLAG( B_FLAG );                \
&#13;
      PUSH( R.P );                        \
&#13;
      SET_FLAG( I_FLAG );                \
&#13;
      R.PC = RD6502W(IRQ_VECTOR);      \
&#13;
      exec_cycles += 7;                \
&#13;
}
&#13;
#define      BRK() {                              \
&#13;
      R.PC++;                              \
&#13;
      PUSH( R.PC&gt;&gt;8 );                \
&#13;
      PUSH( R.PC&amp;0xFF );                \
&#13;
      SET_FLAG( B_FLAG );                \
&#13;
      PUSH( R.P );                        \
&#13;
      SET_FLAG( I_FLAG );                \
&#13;
      R.PC = RD6502W(IRQ_VECTOR);      \
&#13;
}
&#13;
#if      1
&#13;
#define      REL_JUMP() {                \
&#13;
      ET = R.PC;                \
&#13;
      EA = R.PC + (SBYTE)DT;      \
&#13;
      R.PC = EA;                \
&#13;
      ADD_CYCLE(1);                \
&#13;
      CHECK_EA();                \
&#13;
}
&#13;
#else
&#13;
#define      REL_JUMP() {                        \
&#13;
      R.PC = R.PC + (SBYTE)DT;      \
&#13;
      ADD_CYCLE(1);                        \
&#13;
}
&#13;
#endif
&#13;
#define      BCC()      { if( !(R.P &amp; C_FLAG) ) REL_JUMP(); }
&#13;
#define      BCS()      { if((R.P &amp; C_FLAG) ) REL_JUMP(); }
&#13;
#define      BNE()      { if( !(R.P &amp; Z_FLAG) ) REL_JUMP(); }
&#13;
#define      BEQ()      { if((R.P &amp; Z_FLAG) ) REL_JUMP(); }
&#13;
#define      BPL()      { if( !(R.P &amp; N_FLAG) ) REL_JUMP(); }
&#13;
#define      BMI()      { if((R.P &amp; N_FLAG) ) REL_JUMP(); }
&#13;
#define      BVC()      { if( !(R.P &amp; V_FLAG) ) REL_JUMP(); }
&#13;
#define      BVS()      { if((R.P &amp; V_FLAG) ) REL_JUMP(); }
&#13;
// フラグ制御系
&#13;
#define      CLC()      { R.P &amp;= ~C_FLAG; }
&#13;
#define      CLD()      { R.P &amp;= ~D_FLAG; }
&#13;
#define      CLI()      { R.P &amp;= ~I_FLAG; }
&#13;
#define      CLV()      { R.P &amp;= ~V_FLAG; }
&#13;
#define      SEC()      { R.P |= C_FLAG; }
&#13;
#define      SED()      { R.P |= D_FLAG; }
&#13;
#define      SEI()      { R.P |= I_FLAG; }
&#13;
// Unofficial命令
&#13;
#define      ANC()      {                        \
&#13;
      R.A &amp;= DT;                        \
&#13;
      SET_ZN_FLAG( R.A );                \
&#13;
      TST_FLAG( R.P&amp;N_FLAG, C_FLAG );      \
&#13;
}
&#13;
#define      ANE()      {                        \
&#13;
      R.A = (R.A|0xEE)&amp;R.X&amp;DT;      \
&#13;
      SET_ZN_FLAG( R.A );                \
&#13;
}
&#13;
#define      ARR()      {                              \
&#13;
      DT &amp;= R.A;                              \
&#13;
      R.A = (DT&gt;&gt;1)|((R.P&amp;C_FLAG)&lt;&lt;7);      \
&#13;
      SET_ZN_FLAG( R.A );                        \
&#13;
      TST_FLAG( R.A&amp;0x40, C_FLAG );                \
&#13;
      TST_FLAG( (R.A&gt;&gt;6)^(R.A&gt;&gt;5), V_FLAG );      \
&#13;
}
&#13;
#define      ASR()      {                        \
&#13;
      DT &amp;= R.A;                        \
&#13;
      TST_FLAG( DT&amp;0x01, C_FLAG );      \
&#13;
      R.A = DT&gt;&gt;1;                        \
&#13;
      SET_ZN_FLAG( R.A );                \
&#13;
}
&#13;
#define      DCP()      {                        \
&#13;
      DT--;                              \
&#13;
      CMP_();                              \
&#13;
}
&#13;
#define      DOP()      {                        \
&#13;
      R.PC++;                              \
&#13;
}
&#13;
#define      ISB()      {                        \
&#13;
      DT++;                              \
&#13;
      SBC();                              \
&#13;
}
&#13;
#define      LAS()      {                        \
&#13;
      R.A = R.X = R.S = (R.S &amp; DT);      \
&#13;
      SET_ZN_FLAG( R.A );                \
&#13;
}
&#13;
#define      LAX()      {                        \
&#13;
      R.A = DT;                        \
&#13;
      R.X = R.A;                        \
&#13;
      SET_ZN_FLAG( R.A );                \
&#13;
}
&#13;
#define      LXA()      {                        \
&#13;
      R.A = R.X = ((R.A|0xEE)&amp;DT);      \
&#13;
      SET_ZN_FLAG( R.A );                \
&#13;
}
&#13;
#define      RLA()      {                              \
&#13;
      if( R.P &amp; C_FLAG ) {                        \
&#13;
                TST_FLAG( DT&amp;0x80, C_FLAG );      \
&#13;
                DT = (DT&lt;&lt;1)|1;                        \
&#13;
      } else {                              \
&#13;
                TST_FLAG( DT&amp;0x80, C_FLAG );      \
&#13;
                DT &lt;&lt;= 1;                        \
&#13;
      }                                        \
&#13;
      R.A &amp;= DT;                              \
&#13;
      SET_ZN_FLAG( R.A );                        \
&#13;
}
&#13;
#define      RRA()      {                              \
&#13;
      if( R.P &amp; C_FLAG ) {                        \
&#13;
                TST_FLAG( DT&amp;0x01, C_FLAG );      \
&#13;
                DT = (DT&gt;&gt;1)|0x80;                \
&#13;
      } else {                              \
&#13;
                TST_FLAG( DT&amp;0x01, C_FLAG );      \
&#13;
                DT &gt;&gt;= 1;                        \
&#13;
      }                                        \
&#13;
      ADC();                                        \
&#13;
}
&#13;
#define      SAX()      {                        \
&#13;
      DT = R.A &amp; R.X;                        \
&#13;
}
&#13;
#define      SBX()      {                        \
&#13;
      WT = (R.A&amp;R.X)-DT;                \
&#13;
      TST_FLAG( WT &lt; 0x100, C_FLAG );      \
&#13;
      R.X = WT&amp;0xFF;                        \
&#13;
      SET_ZN_FLAG( R.X );                \
&#13;
}
&#13;
#define      SHA()      {                              \
&#13;
      DT = R.A &amp; R.X &amp; (BYTE)((EA&gt;&gt;8)+1);      \
&#13;
}
&#13;
#define      SHS()      {                        \
&#13;
      R.S = R.A &amp; R.X;                \
&#13;
      DT = R.S &amp; (BYTE)((EA&gt;&gt;8)+1);      \
&#13;
}
&#13;
#define      SHX()      {                        \
&#13;
      DT = R.X &amp; (BYTE)((EA&gt;&gt;8)+1);      \
&#13;
}
&#13;
#define      SHY()      {                        \
&#13;
      DT = R.Y &amp; (BYTE)((EA&gt;&gt;8)+1);      \
&#13;
}
&#13;
#define      SLO()      {                        \
&#13;
      TST_FLAG( DT&amp;0x80, C_FLAG );      \
&#13;
      DT &lt;&lt;= 1;                        \
&#13;
      R.A |= DT;                        \
&#13;
      SET_ZN_FLAG( R.A );                \
&#13;
}
&#13;
#define      SRE()      {                        \
&#13;
      TST_FLAG( DT&amp;0x01, C_FLAG );      \
&#13;
      DT &gt;&gt;= 1;                        \
&#13;
      R.A ^= DT;                        \
&#13;
      SET_ZN_FLAG( R.A );                \
&#13;
}
&#13;
#define      TOP()      {                        \
&#13;
      R.PC += 2;                        \
&#13;
}
&#13;
//
&#13;
// コンストラクタ/デストラクタ
&#13;
//
&#13;
//CPU::CPU( NES* parent )
&#13;
CPU::CPU( NES* parent ) : nes(parent)
&#13;
{
&#13;
//      nes = parent;
&#13;
      m_bClockProcess = FALSE;
&#13;
}
&#13;
CPU::~CPU()
&#13;
{
&#13;
}
&#13;
// メモリアクセス
&#13;
//#define      OP6502(A)      (CPU_MEM_BANK[(A)&gt;&gt;13][(A)&amp;0x1FFF])
&#13;
//#define      OP6502W(A)      (*((WORD*)&amp;CPU_MEM_BANK[(A)&gt;&gt;13][(A)&amp;0x1FFF]))
&#13;
#if      0
&#13;
#define      OP6502(A)      RD6502((A))
&#13;
#define      OP6502W(A)      RD6502W((A))
&#13;
#else
&#13;
inline      BYTE      OP6502( WORD addr )
&#13;
{
&#13;
      return      CPU_MEM_BANK;
&#13;
}
&#13;
inline      WORD      OP6502W( WORD addr )
&#13;
{
&#13;
#if      0
&#13;
      WORD      ret;
&#13;
      ret= (WORD)CPU_MEM_BANK[(addr+0)&gt;&gt;13][(addr+0)&amp;0x1FFF];
&#13;
      ret |= (WORD)CPU_MEM_BANK[(addr+1)&gt;&gt;13][(addr+1)&amp;0x1FFF]&lt;&lt;8;
&#13;
      return      ret;
&#13;
#else
&#13;
      return      *((WORD*)&amp;CPU_MEM_BANK);
&#13;
#endif
&#13;
}
&#13;
#endif
&#13;
inline      BYTE      CPU::RD6502( WORD addr )
&#13;
{
&#13;
      if( addr &lt; 0x2000 ) {
&#13;
      // RAM (Mirror $0800, $1000, $1800)
&#13;
                return      RAM;
&#13;
      } else if( addr &lt; 0x8000 ) {
&#13;
      // Others
&#13;
                return      nes-&gt;Read( addr );
&#13;
      } else {
&#13;
      // Dummy access
&#13;
                mapper-&gt;Read( addr, CPU_MEM_BANK );
&#13;
      }
&#13;
      // Quick bank read
&#13;
      return      CPU_MEM_BANK;
&#13;
}
&#13;
inline      WORD      CPU::RD6502W( WORD addr )
&#13;
{
&#13;
      if( addr &lt; 0x2000 ) {
&#13;
      // RAM (Mirror $0800, $1000, $1800)
&#13;
                return      *((WORD*)&amp;RAM);
&#13;
      } else if( addr &lt; 0x8000 ) {
&#13;
      // Others
&#13;
                return      (WORD)nes-&gt;Read(addr)+(WORD)nes-&gt;Read(addr+1)*0x100;
&#13;
      }
&#13;
      // Quick bank read
&#13;
#if      0
&#13;
      WORD      ret;
&#13;
      ret= (WORD)CPU_MEM_BANK[(addr+0)&gt;&gt;13][(addr+0)&amp;0x1FFF];
&#13;
      ret |= (WORD)CPU_MEM_BANK[(addr+1)&gt;&gt;13][(addr+1)&amp;0x1FFF]&lt;&lt;8;
&#13;
      return      ret;
&#13;
#else
&#13;
      return      *((WORD*)&amp;CPU_MEM_BANK);
&#13;
#endif
&#13;
}
&#13;
// メモリライト
&#13;
inline      void      CPU::WR6502( WORD addr, BYTE data )
&#13;
{
&#13;
      if( addr &lt; 0x2000 ) {
&#13;
      // RAM (Mirror $0800, $1000, $1800)
&#13;
                RAM = data;
&#13;
      } else {
&#13;
      // Others
&#13;
                nes-&gt;Write( addr, data );
&#13;
      }
&#13;
}
&#13;
//
&#13;
// リセット
&#13;
//
&#13;
void      CPU::Reset()
&#13;
{
&#13;
      apu = nes-&gt;apu;
&#13;
      mapper = nes-&gt;mapper;
&#13;
      R.A= 0x00;
&#13;
      R.X= 0x00;
&#13;
      R.Y= 0x00;
&#13;
      R.S= 0xFF;
&#13;
      R.P= Z_FLAG|R_FLAG;
&#13;
      R.PC = RD6502W(RES_VECTOR);
&#13;
      R.INT_pending = 0;
&#13;
      TOTAL_cycles = 0;
&#13;
      DMA_cycles = 0;
&#13;
      // STACK quick access
&#13;
      STACK = &amp;RAM;
&#13;
      // Zero/Negative FLAG
&#13;
      ZN_Table = Z_FLAG;
&#13;
      for( INT i = 1; i &lt; 256; i++ )
&#13;
                ZN_Table = (i &amp; 0x80)?N_FLAG:0;
&#13;
}
&#13;
INT      CPU::GetDmaCycles()
&#13;
{
&#13;
      return      DMA_cycles;
&#13;
}
&#13;
void      CPU::SetDmaCycles( INT cycles )
&#13;
{
&#13;
      DMA_cycles = cycles;
&#13;
}
&#13;
INT      CPU::GetTotalCycles()
&#13;
{
&#13;
      return      TOTAL_cycles;
&#13;
}
&#13;
void      CPU::SetTotalCycles( INT cycles )
&#13;
{
&#13;
      TOTAL_cycles = cycles;
&#13;
}
&#13;
//
&#13;
// DMAペンディングサイクル設定
&#13;
//
&#13;
void      CPU::DMA( INT cycles )
&#13;
{
&#13;
      DMA_cycles += cycles;
&#13;
}
&#13;
static      int      nmicount;
&#13;
//
&#13;
// 割り込み
&#13;
//
&#13;
void      CPU::NMI()
&#13;
{
&#13;
      R.INT_pending |= NMI_FLAG;
&#13;
      nmicount = 0;
&#13;
}
&#13;
void      CPU::SetIRQ( BYTE mask )
&#13;
{
&#13;
      R.INT_pending |= mask;
&#13;
}
&#13;
void      CPU::ClrIRQ( BYTE mask )
&#13;
{
&#13;
      R.INT_pending &amp;= ~mask;
&#13;
}
&#13;
//
&#13;
// 命令実行
&#13;
//
&#13;
INT      CPU::EXEC( INT request_cycles )
&#13;
{
&#13;
BYTE      opcode;                // オペコード
&#13;
INT      OLD_cycles = TOTAL_cycles;
&#13;
INT      exec_cycles;
&#13;
BYTE      nmi_request, irq_request;
&#13;
BOOL      bClockProcess = m_bClockProcess;
&#13;
// TEMP
&#13;
register WORD      EA;
&#13;
register WORD      ET;
&#13;
register WORD      WT;
&#13;
register BYTE      DT;
&#13;
      while( request_cycles &gt; 0 ) {
&#13;
                exec_cycles = 0;
&#13;
                if( DMA_cycles ) {
&#13;
                        if( request_cycles &lt;= DMA_cycles ) {
&#13;
                              DMA_cycles -= request_cycles;
&#13;
                              TOTAL_cycles += request_cycles;
&#13;
                              // クロック同期処理
&#13;
                              mapper-&gt;Clock( request_cycles );
&#13;
#if      DPCM_SYNCCLOCK
&#13;
                              apu-&gt;SyncDPCM( request_cycles );
&#13;
#endif
&#13;
                              if( bClockProcess ) {
&#13;
                                        nes-&gt;Clock( request_cycles );
&#13;
                              }
&#13;
//                              nes-&gt;Clock( request_cycles );
&#13;
                              goto      _execute_exit;
&#13;
                        } else {
&#13;
                              exec_cycles += DMA_cycles;
&#13;
//                              request_cycles -= DMA_cycles;
&#13;
                              DMA_cycles = 0;
&#13;
                        }
&#13;
                }
&#13;
                nmi_request = irq_request = 0;
&#13;
                opcode = OP6502( R.PC++ );
&#13;
                if( R.INT_pending ) {
&#13;
                        if( R.INT_pending &amp; NMI_FLAG ) {
&#13;
                              nmi_request = 0xFF;
&#13;
                              R.INT_pending &amp;= ~NMI_FLAG;
&#13;
                        } else
&#13;
                        if( R.INT_pending &amp; IRQ_MASK ) {
&#13;
                              R.INT_pending &amp;= ~IRQ_TRIGGER2;
&#13;
                              if( !(R.P &amp; I_FLAG) &amp;&amp; opcode != 0x40 ) {
&#13;
                                        irq_request = 0xFF;
&#13;
                                        R.INT_pending &amp;= ~IRQ_TRIGGER;
&#13;
                              }
&#13;
                        }
&#13;
                }
&#13;
                switch( opcode ) {
&#13;
                        case      0x69: // ADC #$??
&#13;
                              MR_IM(); ADC();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x65: // ADC $??
&#13;
                              MR_ZP(); ADC();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0x75: // ADC $??,X
&#13;
                              MR_ZX(); ADC();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x6D: // ADC $????
&#13;
                              MR_AB(); ADC();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x7D: // ADC $????,X
&#13;
                              MR_AX(); ADC(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x79: // ADC $????,Y
&#13;
                              MR_AY(); ADC(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x61: // ADC ($??,X)
&#13;
                              MR_IX(); ADC();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x71: // ADC ($??),Y
&#13;
                              MR_IY(); ADC(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xE9: // SBC #$??
&#13;
                              MR_IM(); SBC();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xE5: // SBC $??
&#13;
                              MR_ZP(); SBC();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0xF5: // SBC $??,X
&#13;
                              MR_ZX(); SBC();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xED: // SBC $????
&#13;
                              MR_AB(); SBC();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xFD: // SBC $????,X
&#13;
                              MR_AX(); SBC(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xF9: // SBC $????,Y
&#13;
                              MR_AY(); SBC(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xE1: // SBC ($??,X)
&#13;
                              MR_IX(); SBC();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0xF1: // SBC ($??),Y
&#13;
                              MR_IY(); SBC(); CHECK_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0xC6: // DEC $??
&#13;
                              MR_ZP(); DEC();      MW_ZP();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0xD6: // DEC $??,X
&#13;
                              MR_ZX(); DEC(); MW_ZP();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0xCE: // DEC $????
&#13;
                              MR_AB(); DEC(); MW_EA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0xDE: // DEC $????,X
&#13;
                              MR_AX(); DEC(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0xCA: // DEX
&#13;
                              DEX();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x88: // DEY
&#13;
                              DEY();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xE6: // INC $??
&#13;
                              MR_ZP(); INC(); MW_ZP();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0xF6: // INC $??,X
&#13;
                              MR_ZX(); INC(); MW_ZP();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0xEE: // INC $????
&#13;
                              MR_AB(); INC(); MW_EA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0xFE: // INC $????,X
&#13;
                              MR_AX(); INC(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0xE8: // INX
&#13;
                              INX();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xC8: // INY
&#13;
                              INY();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x29: // AND #$??
&#13;
                              MR_IM(); AND();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x25: // AND $??
&#13;
                              MR_ZP(); AND();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0x35: // AND $??,X
&#13;
                              MR_ZX(); AND();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x2D: // AND $????
&#13;
                              MR_AB(); AND();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x3D: // AND $????,X
&#13;
                              MR_AX(); AND(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x39: // AND $????,Y
&#13;
                              MR_AY(); AND(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x21: // AND ($??,X)
&#13;
                              MR_IX(); AND();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x31: // AND ($??),Y
&#13;
                              MR_IY(); AND(); CHECK_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x0A: // ASL A
&#13;
                              ASL_A();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x06: // ASL $??
&#13;
                              MR_ZP(); ASL(); MW_ZP();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x16: // ASL $??,X
&#13;
                              MR_ZX(); ASL(); MW_ZP();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x0E: // ASL $????
&#13;
                              MR_AB(); ASL(); MW_EA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x1E: // ASL $????,X
&#13;
                              MR_AX(); ASL(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0x24: // BIT $??
&#13;
                              MR_ZP(); BIT();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0x2C: // BIT $????
&#13;
                              MR_AB(); BIT();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x49: // EOR #$??
&#13;
                              MR_IM(); EOR();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x45: // EOR $??
&#13;
                              MR_ZP(); EOR();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0x55: // EOR $??,X
&#13;
                              MR_ZX(); EOR();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x4D: // EOR $????
&#13;
                              MR_AB(); EOR();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x5D: // EOR $????,X
&#13;
                              MR_AX(); EOR(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x59: // EOR $????,Y
&#13;
                              MR_AY(); EOR(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x41: // EOR ($??,X)
&#13;
                              MR_IX(); EOR();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x51: // EOR ($??),Y
&#13;
                              MR_IY(); EOR(); CHECK_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x4A: // LSR A
&#13;
                              LSR_A();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x46: // LSR $??
&#13;
                              MR_ZP(); LSR(); MW_ZP();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x56: // LSR $??,X
&#13;
                              MR_ZX(); LSR(); MW_ZP();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x4E: // LSR $????
&#13;
                              MR_AB(); LSR(); MW_EA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x5E: // LSR $????,X
&#13;
                              MR_AX(); LSR(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0x09: // ORA #$??
&#13;
                              MR_IM(); ORA();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x05: // ORA $??
&#13;
                              MR_ZP(); ORA();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0x15: // ORA $??,X
&#13;
                              MR_ZX(); ORA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x0D: // ORA $????
&#13;
                              MR_AB(); ORA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x1D: // ORA $????,X
&#13;
                              MR_AX(); ORA(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x19: // ORA $????,Y
&#13;
                              MR_AY(); ORA(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x01: // ORA ($??,X)
&#13;
                              MR_IX(); ORA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x11: // ORA ($??),Y
&#13;
                              MR_IY(); ORA(); CHECK_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x2A: // ROL A
&#13;
                              ROL_A();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x26: // ROL $??
&#13;
                              MR_ZP(); ROL(); MW_ZP();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x36: // ROL $??,X
&#13;
                              MR_ZX(); ROL(); MW_ZP();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x2E: // ROL $????
&#13;
                              MR_AB(); ROL(); MW_EA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x3E: // ROL $????,X
&#13;
                              MR_AX(); ROL(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0x6A: // ROR A
&#13;
                              ROR_A();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x66: // ROR $??
&#13;
                              MR_ZP(); ROR(); MW_ZP();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x76: // ROR $??,X
&#13;
                              MR_ZX(); ROR(); MW_ZP();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x6E: // ROR $????
&#13;
                              MR_AB(); ROR(); MW_EA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x7E: // ROR $????,X
&#13;
                              MR_AX(); ROR(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0xA9: // LDA #$??
&#13;
                              MR_IM(); LDA();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xA5: // LDA $??
&#13;
                              MR_ZP(); LDA();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0xB5: // LDA $??,X
&#13;
                              MR_ZX(); LDA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xAD: // LDA $????
&#13;
                              MR_AB(); LDA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xBD: // LDA $????,X
&#13;
                              MR_AX(); LDA(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xB9: // LDA $????,Y
&#13;
                              MR_AY(); LDA(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xA1: // LDA ($??,X)
&#13;
                              MR_IX(); LDA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0xB1: // LDA ($??),Y
&#13;
                              MR_IY(); LDA(); CHECK_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0xA2: // LDX #$??
&#13;
                              MR_IM(); LDX();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xA6: // LDX $??
&#13;
                              MR_ZP(); LDX();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0xB6: // LDX $??,Y
&#13;
                              MR_ZY(); LDX();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xAE: // LDX $????
&#13;
                              MR_AB(); LDX();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xBE: // LDX $????,Y
&#13;
                              MR_AY(); LDX(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xA0: // LDY #$??
&#13;
                              MR_IM(); LDY();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xA4: // LDY $??
&#13;
                              MR_ZP(); LDY();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0xB4: // LDY $??,X
&#13;
                              MR_ZX(); LDY();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xAC: // LDY $????
&#13;
                              MR_AB(); LDY();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xBC: // LDY $????,X
&#13;
                              MR_AX(); LDY(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x85: // STA $??
&#13;
                              EA_ZP(); STA(); MW_ZP();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0x95: // STA $??,X
&#13;
                              EA_ZX(); STA(); MW_ZP();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x8D: // STA $????
&#13;
                              EA_AB(); STA(); MW_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x9D: // STA $????,X
&#13;
                              EA_AX(); STA(); MW_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x99: // STA $????,Y
&#13;
                              EA_AY(); STA(); MW_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x81: // STA ($??,X)
&#13;
                              EA_IX(); STA(); MW_EA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x91: // STA ($??),Y
&#13;
                              EA_IY(); STA(); MW_EA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x86: // STX $??
&#13;
                              EA_ZP(); STX(); MW_ZP();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0x96: // STX $??,Y
&#13;
                              EA_ZY(); STX(); MW_ZP();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x8E: // STX $????
&#13;
                              EA_AB(); STX(); MW_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x84: // STY $??
&#13;
                              EA_ZP(); STY(); MW_ZP();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0x94: // STY $??,X
&#13;
                              EA_ZX(); STY(); MW_ZP();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x8C: // STY $????
&#13;
                              EA_AB(); STY(); MW_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xAA: // TAX
&#13;
                              TAX();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x8A: // TXA
&#13;
                              TXA();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xA8: // TAY
&#13;
                              TAY();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x98: // TYA
&#13;
                              TYA();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xBA: // TSX
&#13;
                              TSX();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x9A: // TXS
&#13;
                              TXS();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xC9: // CMP #$??
&#13;
                              MR_IM(); CMP_();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xC5: // CMP $??
&#13;
                              MR_ZP(); CMP_();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0xD5: // CMP $??,X
&#13;
                              MR_ZX(); CMP_();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xCD: // CMP $????
&#13;
                              MR_AB(); CMP_();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xDD: // CMP $????,X
&#13;
                              MR_AX(); CMP_(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xD9: // CMP $????,Y
&#13;
                              MR_AY(); CMP_(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xC1: // CMP ($??,X)
&#13;
                              MR_IX(); CMP_();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0xD1: // CMP ($??),Y
&#13;
                              MR_IY(); CMP_(); CHECK_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0xE0: // CPX #$??
&#13;
                              MR_IM(); CPX();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xE4: // CPX $??
&#13;
                              MR_ZP(); CPX();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0xEC: // CPX $????
&#13;
                              MR_AB(); CPX();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xC0: // CPY #$??
&#13;
                              MR_IM(); CPY();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xC4: // CPY $??
&#13;
                              MR_ZP(); CPY();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0xCC: // CPY $????
&#13;
                              MR_AB(); CPY();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x90: // BCC
&#13;
                              MR_IM(); BCC();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xB0: // BCS
&#13;
                              MR_IM(); BCS();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xF0: // BEQ
&#13;
                              MR_IM(); BEQ();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x30: // BMI
&#13;
                              MR_IM(); BMI();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xD0: // BNE
&#13;
                              MR_IM(); BNE();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x10: // BPL
&#13;
                              MR_IM(); BPL();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x50: // BVC
&#13;
                              MR_IM(); BVC();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x70: // BVS
&#13;
                              MR_IM(); BVS();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x4C: // JMP $????
&#13;
                              JMP();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0x6C: // JMP ($????)
&#13;
                              JMP_ID();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x20: // JSR
&#13;
                              JSR();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x40: // RTI
&#13;
                              RTI();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x60: // RTS
&#13;
                              RTS();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
      // フラグ制御系
&#13;
                        case      0x18: // CLC
&#13;
                              CLC();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xD8: // CLD
&#13;
                              CLD();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x58: // CLI
&#13;
                              CLI();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xB8: // CLV
&#13;
                              CLV();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x38: // SEC
&#13;
                              SEC();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xF8: // SED
&#13;
                              SED();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x78: // SEI
&#13;
                              SEI();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
      // スタック系
&#13;
                        case      0x48: // PHA
&#13;
                              PUSH( R.A );
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0x08: // PHP
&#13;
                              PUSH( R.P | B_FLAG );
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0x68: // PLA (N-----Z-)
&#13;
                              R.A = POP();
&#13;
                              SET_ZN_FLAG(R.A);
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x28: // PLP
&#13;
                              R.P = POP() | R_FLAG;
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
      // その他
&#13;
                        case      0x00: // BRK
&#13;
                              BRK();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0xEA: // NOP
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
      // 未公開命令群
&#13;
                        case      0x0B: // ANC #$??
&#13;
                        case      0x2B: // ANC #$??
&#13;
                              MR_IM(); ANC();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x8B: // ANE #$??
&#13;
                              MR_IM(); ANE();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x6B: // ARR #$??
&#13;
                              MR_IM(); ARR();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x4B: // ASR #$??
&#13;
                              MR_IM(); ASR();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0xC7: // DCP $??
&#13;
                              MR_ZP(); DCP(); MW_ZP();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0xD7: // DCP $??,X
&#13;
                              MR_ZX(); DCP(); MW_ZP();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0xCF: // DCP $????
&#13;
                              MR_AB(); DCP(); MW_EA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0xDF: // DCP $????,X
&#13;
                              MR_AX(); DCP(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0xDB: // DCP $????,Y
&#13;
                              MR_AY(); DCP(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0xC3: // DCP ($??,X)
&#13;
                              MR_IX(); DCP(); MW_EA();
&#13;
                              ADD_CYCLE(8);
&#13;
                              break;
&#13;
                        case      0xD3: // DCP ($??),Y
&#13;
                              MR_IY(); DCP(); MW_EA();
&#13;
                              ADD_CYCLE(8);
&#13;
                              break;
&#13;
                        case      0xE7: // ISB $??
&#13;
                              MR_ZP(); ISB(); MW_ZP();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0xF7: // ISB $??,X
&#13;
                              MR_ZX(); ISB(); MW_ZP();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0xEF: // ISB $????
&#13;
                              MR_AB(); ISB(); MW_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0xFF: // ISB $????,X
&#13;
                              MR_AX(); ISB(); MW_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0xFB: // ISB $????,Y
&#13;
                              MR_AY(); ISB(); MW_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0xE3: // ISB ($??,X)
&#13;
                              MR_IX(); ISB(); MW_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0xF3: // ISB ($??),Y
&#13;
                              MR_IY(); ISB(); MW_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0xBB: // LAS $????,Y
&#13;
                              MR_AY(); LAS(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xA7: // LAX $??
&#13;
                              MR_ZP(); LAX();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0xB7: // LAX $??,Y
&#13;
                              MR_ZY(); LAX();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xAF: // LAX $????
&#13;
                              MR_AB(); LAX();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xBF: // LAX $????,Y
&#13;
                              MR_AY(); LAX(); CHECK_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0xA3: // LAX ($??,X)
&#13;
                              MR_IX(); LAX();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0xB3: // LAX ($??),Y
&#13;
                              MR_IY(); LAX(); CHECK_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0xAB: // LXA #$??
&#13;
                              MR_IM(); LXA();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x27: // RLA $??
&#13;
                              MR_ZP(); RLA(); MW_ZP();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x37: // RLA $??,X
&#13;
                              MR_ZX(); RLA(); MW_ZP();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x2F: // RLA $????
&#13;
                              MR_AB(); RLA(); MW_EA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x3F: // RLA $????,X
&#13;
                              MR_AX(); RLA(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0x3B: // RLA $????,Y
&#13;
                              MR_AY(); RLA(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0x23: // RLA ($??,X)
&#13;
                              MR_IX(); RLA(); MW_EA();
&#13;
                              ADD_CYCLE(8);
&#13;
                              break;
&#13;
                        case      0x33: // RLA ($??),Y
&#13;
                              MR_IY(); RLA(); MW_EA();
&#13;
                              ADD_CYCLE(8);
&#13;
                              break;
&#13;
                        case      0x67: // RRA $??
&#13;
                              MR_ZP(); RRA(); MW_ZP();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x77: // RRA $??,X
&#13;
                              MR_ZX(); RRA(); MW_ZP();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x6F: // RRA $????
&#13;
                              MR_AB(); RRA(); MW_EA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x7F: // RRA $????,X
&#13;
                              MR_AX(); RRA(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0x7B: // RRA $????,Y
&#13;
                              MR_AY(); RRA(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0x63: // RRA ($??,X)
&#13;
                              MR_IX(); RRA(); MW_EA();
&#13;
                              ADD_CYCLE(8);
&#13;
                              break;
&#13;
                        case      0x73: // RRA ($??),Y
&#13;
                              MR_IY(); RRA(); MW_EA();
&#13;
                              ADD_CYCLE(8);
&#13;
                              break;
&#13;
                        case      0x87: // SAX $??
&#13;
                              MR_ZP(); SAX(); MW_ZP();
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0x97: // SAX $??,Y
&#13;
                              MR_ZY(); SAX(); MW_ZP();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x8F: // SAX $????
&#13;
                              MR_AB(); SAX(); MW_EA();
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x83: // SAX ($??,X)
&#13;
                              MR_IX(); SAX(); MW_EA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0xCB: // SBX #$??
&#13;
                              MR_IM(); SBX();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x9F: // SHA $????,Y
&#13;
                              MR_AY(); SHA(); MW_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x93: // SHA ($??),Y
&#13;
                              MR_IY(); SHA(); MW_EA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x9B: // SHS $????,Y
&#13;
                              MR_AY(); SHS(); MW_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x9E: // SHX $????,Y
&#13;
                              MR_AY(); SHX(); MW_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x9C: // SHY $????,X
&#13;
                              MR_AX(); SHY(); MW_EA();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x07: // SLO $??
&#13;
                              MR_ZP(); SLO(); MW_ZP();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x17: // SLO $??,X
&#13;
                              MR_ZX(); SLO(); MW_ZP();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x0F: // SLO $????
&#13;
                              MR_AB(); SLO(); MW_EA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x1F: // SLO $????,X
&#13;
                              MR_AX(); SLO(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0x1B: // SLO $????,Y
&#13;
                              MR_AY(); SLO(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0x03: // SLO ($??,X)
&#13;
                              MR_IX(); SLO(); MW_EA();
&#13;
                              ADD_CYCLE(8);
&#13;
                              break;
&#13;
                        case      0x13: // SLO ($??),Y
&#13;
                              MR_IY(); SLO(); MW_EA();
&#13;
                              ADD_CYCLE(8);
&#13;
                              break;
&#13;
                        case      0x47: // SRE $??
&#13;
                              MR_ZP(); SRE(); MW_ZP();
&#13;
                              ADD_CYCLE(5);
&#13;
                              break;
&#13;
                        case      0x57: // SRE $??,X
&#13;
                              MR_ZX(); SRE(); MW_ZP();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x4F: // SRE $????
&#13;
                              MR_AB(); SRE(); MW_EA();
&#13;
                              ADD_CYCLE(6);
&#13;
                              break;
&#13;
                        case      0x5F: // SRE $????,X
&#13;
                              MR_AX(); SRE(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0x5B: // SRE $????,Y
&#13;
                              MR_AY(); SRE(); MW_EA();
&#13;
                              ADD_CYCLE(7);
&#13;
                              break;
&#13;
                        case      0x43: // SRE ($??,X)
&#13;
                              MR_IX(); SRE(); MW_EA();
&#13;
                              ADD_CYCLE(8);
&#13;
                              break;
&#13;
                        case      0x53: // SRE ($??),Y
&#13;
                              MR_IY(); SRE(); MW_EA();
&#13;
                              ADD_CYCLE(8);
&#13;
                              break;
&#13;
                        case      0xEB: // SBC #$?? (Unofficial)
&#13;
                              MR_IM(); SBC();
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x1A: // NOP (Unofficial)
&#13;
                        case      0x3A: // NOP (Unofficial)
&#13;
                        case      0x5A: // NOP (Unofficial)
&#13;
                        case      0x7A: // NOP (Unofficial)
&#13;
                        case      0xDA: // NOP (Unofficial)
&#13;
                        case      0xFA: // NOP (Unofficial)
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x80: // DOP (CYCLES 2)
&#13;
                        case      0x82: // DOP (CYCLES 2)
&#13;
                        case      0x89: // DOP (CYCLES 2)
&#13;
                        case      0xC2: // DOP (CYCLES 2)
&#13;
                        case      0xE2: // DOP (CYCLES 2)
&#13;
                              R.PC++;
&#13;
                              ADD_CYCLE(2);
&#13;
                              break;
&#13;
                        case      0x04: // DOP (CYCLES 3)
&#13;
                        case      0x44: // DOP (CYCLES 3)
&#13;
                        case      0x64: // DOP (CYCLES 3)
&#13;
                              R.PC++;
&#13;
                              ADD_CYCLE(3);
&#13;
                              break;
&#13;
                        case      0x14: // DOP (CYCLES 4)
&#13;
                        case      0x34: // DOP (CYCLES 4)
&#13;
                        case      0x54: // DOP (CYCLES 4)
&#13;
                        case      0x74: // DOP (CYCLES 4)
&#13;
                        case      0xD4: // DOP (CYCLES 4)
&#13;
                        case      0xF4: // DOP (CYCLES 4)
&#13;
                              R.PC++;
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x0C: // TOP
&#13;
                        case      0x1C: // TOP
&#13;
                        case      0x3C: // TOP
&#13;
                        case      0x5C: // TOP
&#13;
                        case      0x7C: // TOP
&#13;
                        case      0xDC: // TOP
&#13;
                        case      0xFC: // TOP
&#13;
                              R.PC+=2;
&#13;
                              ADD_CYCLE(4);
&#13;
                              break;
&#13;
                        case      0x02:/* JAM */
&#13;
                        case      0x12:/* JAM */
&#13;
                        case      0x22:/* JAM */
&#13;
                        case      0x32:/* JAM */
&#13;
                        case      0x42:/* JAM */
&#13;
                        case      0x52:/* JAM */
&#13;
                        case      0x62:/* JAM */
&#13;
                        case      0x72:/* JAM */
&#13;
                        case      0x92:/* JAM */
&#13;
                        case      0xB2:/* JAM */
&#13;
                        case      0xD2:/* JAM */
&#13;
                        case      0xF2:/* JAM */
&#13;
                        default:
&#13;
                              if( !Config.emulator.bIllegalOp ) {
&#13;
                                        throw      CApp::GetErrorString( IDS_ERROR_ILLEGALOPCODE );
&#13;
                                        goto      _execute_exit;
&#13;
                              } else {
&#13;
                                        R.PC--;
&#13;
                                        ADD_CYCLE(4);
&#13;
                              }
&#13;
                              break;
&#13;
//                        default:
&#13;
//                              __assume(0);
&#13;
                }
&#13;
                if( nmi_request ) {
&#13;
                        _NMI();
&#13;
                } else
&#13;
                if( irq_request ) {
&#13;
                        _IRQ();
&#13;
                }
&#13;
                request_cycles -= exec_cycles;
&#13;
                TOTAL_cycles += exec_cycles;
&#13;
                // クロック同期処理
&#13;
                mapper-&gt;Clock( exec_cycles );
&#13;
#if      DPCM_SYNCCLOCK
&#13;
                apu-&gt;SyncDPCM( exec_cycles );
&#13;
#endif
&#13;
                if( bClockProcess ) {
&#13;
                        nes-&gt;Clock( exec_cycles );
&#13;
                }
&#13;
//                nes-&gt;Clock( exec_cycles );
&#13;
      }
&#13;
_execute_exit:
&#13;
#if      !DPCM_SYNCCLOCK
&#13;
      apu-&gt;SyncDPCM( TOTAL_cycles - OLD_cycles );
&#13;
#endif
&#13;
      return      TOTAL_cycles - OLD_cycles;
&#13;
}</description>
      <content:encoded><![CDATA[<p><b>CAMUS.net: </b><br>
<span>找了一个别人写的最简单的C/C++代码来看，直接放弃编程梦想</span><br>
<span> 本帖最后由 CAMUS.net 于 2019-7-4 13:03 编辑 </span><br>
<span>//////////////////////////////////////////////////////////////////////////</span><br>
<span>//                                                                      //</span><br>
<span>//      6502 CPU core                                                   //</span><br>
<span>//                                                         Norix      //</span><br>
<span>//                                             written   2001/02/22 //</span><br>
<span>//                                             last modify ----/--/-- //</span><br>
<span>//////////////////////////////////////////////////////////////////////////</span><br>
<span>#ifndef      __CPU_INCLUDED__</span><br>
<span>#define      __CPU_INCLUDED__</span><br>
<span>#include "typedef.h"</span><br>
<span>#include "macro.h"</span><br>
<span>class      NES;</span><br>
<span>class      APU;</span><br>
<span>class      Mapper;</span><br>
<span>// 6502 status flags</span><br>
<span>#define      C_FLAG                0x01                // 1: Carry</span><br>
<span>#define      Z_FLAG                0x02                // 1: Zero</span><br>
<span>#define      I_FLAG                0x04                // 1: Irq disabled</span><br>
<span>#define      D_FLAG                0x08                // 1: Decimal mode flag (NES unused)</span><br>
<span>#define      B_FLAG                0x10                // 1: Break</span><br>
<span>#define      R_FLAG                0x20                // 1: Reserved (Always 1)</span><br>
<span>#define      V_FLAG                0x40                // 1: Overflow</span><br>
<span>#define      N_FLAG                0x80                // 1: Negative</span><br>
<span>// Interrupt</span><br>
<span>#define      NMI_FLAG      0x01</span><br>
<span>#define      IRQ_FLAG      0x02</span><br>
<span>#define      IRQ_FRAMEIRQ      0x04</span><br>
<span>#define      IRQ_DPCM      0x08</span><br>
<span>#define      IRQ_MAPPER      0x10</span><br>
<span>#define      IRQ_MAPPER2      0x20</span><br>
<span>#define      IRQ_TRIGGER      0x40                // one shot(旧IRQ())</span><br>
<span>#define      IRQ_TRIGGER2      0x80                // one shot(旧IRQ_NotPending())</span><br>
<span>#define      IRQ_MASK      (~(NMI_FLAG|IRQ_FLAG))</span><br>
<span>// Vector</span><br>
<span>#define      NMI_VECTOR      0xFFFA</span><br>
<span>#define      RES_VECTOR      0xFFFC</span><br>
<span>#define      IRQ_VECTOR      0xFFFE</span><br>
<span>// 6502 context</span><br>
<span>typedef      struct      {</span><br>
<span>      WORD      PC;      /* Program counter   */</span><br>
<span>      BYTE      A;      /* CPU registers   */</span><br>
<span>      BYTE      P;</span><br>
<span>      BYTE      X;</span><br>
<span>      BYTE      Y;</span><br>
<span>      BYTE      S;</span><br>
<span>      BYTE      INT_pending;      // 割り込みペンディングフラグ</span><br>
<span>} R6502;</span><br>
<span>class      CPU</span><br>
<span>{</span><br>
<span>public:</span><br>
<span>      CPU( NES* parent );</span><br>
<span>      virtual      ~CPU();</span><br>
<span>      BYTE      RD6502( WORD addr );</span><br>
<span>      void      WR6502( WORD addr, BYTE data );</span><br>
<span>      WORD      RD6502W( WORD addr );</span><br>
<span>      void      Reset();</span><br>
<span>      void      NMI();</span><br>
<span>      void      SetIRQ( BYTE mask );</span><br>
<span>      void      ClrIRQ( BYTE mask );</span><br>
<span>      void      DMA( INT cycles );</span><br>
<span>      INT      EXEC( INT request_cycles );</span><br>
<span>      INT      GetDmaCycles();</span><br>
<span>      void      SetDmaCycles( INT cycles );</span><br>
<span>      INT      GetTotalCycles();</span><br>
<span>      void      SetTotalCycles( INT cycles );</span><br>
<span>      void      SetContext( R6502 r )      { R = r; }</span><br>
<span>      void      GetContext( R6502& r )      { r = R; }</span><br>
<span>      void      SetClockProcess( BOOL bEnable ) { m_bClockProcess = bEnable; }</span><br>
<span>protected:</span><br>
<span>      NES*      nes;</span><br>
<span>      APU*      apu;</span><br>
<span>      Mapper*      mapper;</span><br>
<span>      R6502      R;</span><br>
<span>      INT      TOTAL_cycles;      // CPUトータルサイクル数</span><br>
<span>      INT      DMA_cycles;      // DMAサイクル数</span><br>
<span>      // PTR</span><br>
<span>      LPBYTE      STACK;</span><br>
<span>      // Zero & Negative table</span><br>
<span>      BYTE      ZN_Table;</span><br>
<span>      // Clock process</span><br>
<span>      BOOL      m_bClockProcess;</span><br>
<span>private:</span><br>
<span>};</span><br>
<span>#endif      // !__CPU_INCLUDED__</span><br>
<span>/*----------------------------------------------------------------------*/</span><br>
<span>/*                                                                      */</span><br>
<span>/*      6502 CPU Core v0.00                                             */</span><br>
<span>/*                                                         Norix      */</span><br>
<span>/*                                             written   2000/12/23 */</span><br>
<span>/*                                             last modify ----/--/-- */</span><br>
<span>/*----------------------------------------------------------------------*/</span><br>
<span>/*--------------[ INCLUDE               ]-------------------------------*/</span><br>
<span>#define      WIN32_LEAN_AND_MEAN</span><br>
<span>#include <windows.h></span><br>
<span>#include "VirtuaNESres.h"</span><br>
<span>#include "typedef.h"</span><br>
<span>#include "macro.h"</span><br>
<span>#include "DebugOut.h"</span><br>
<span>#include "App.h"</span><br>
<span>#include "Config.h"</span><br>
<span>#include "nes.h"</span><br>
<span>#include "mmu.h"</span><br>
<span>#include "cpu.h"</span><br>
<span>#include "ppu.h"</span><br>
<span>#include "apu.h"</span><br>
<span>#include "rom.h"</span><br>
<span>#include "mapper.h"</span><br>
<span>/*--------------[ DEFINE                ]-------------------------------*/</span><br>
<span>#define      DPCM_SYNCCLOCK      FALSE</span><br>
<span>/*--------------[ EXTERNAL PROGRAM      ]-------------------------------*/</span><br>
<span>/*--------------[ EXTERNAL WORK         ]-------------------------------*/</span><br>
<span>/*--------------[ WORK                  ]-------------------------------*/</span><br>
<span>/*--------------[ CONST               ]-------------------------------*/</span><br>
<span>/*--------------[ PROTOTYPE             ]-------------------------------*/</span><br>
<span>/*--------------[ PROGRAM               ]-------------------------------*/</span><br>
<span>// オペコード</span><br>
<span>//#define      OP6502(A)      RD6502((A))</span><br>
<span>//#define      OP6502W(A)      RD6502W((A))</span><br>
<span>// ゼロページリード</span><br>
<span>#define      ZPRD(A)                (RAM[(BYTE)(A)])</span><br>
<span>//#define      ZPRDW(A)      (*((LPWORD)&RAM[(BYTE)(A)]))</span><br>
<span>#define      ZPRDW(A)      ((WORD)RAM[(BYTE)(A)]+((WORD)RAM[(BYTE)((A)+1)]<<8))</span><br>
<span>#define      ZPWR(A,V)      { RAM[(BYTE)(A)]=(V); }</span><br>
<span>#define      ZPWRW(A,V)      { *((LPWORD)&RAM[(BYTE)(A)])=(WORD)(V); }</span><br>
<span>// サイクルカウンタ</span><br>
<span>#define      ADD_CYCLE(V)      { exec_cycles += (V); }</span><br>
<span>//#define      ADD_CYCLE(V)      {}</span><br>
<span>// EFFECTIVE ADDRESSページ境界超えチェック</span><br>
<span>#define      CHECK_EA()      { if( (ET&0xFF00) != (EA&0xFF00) ) ADD_CYCLE(1); }</span><br>
<span>//#define      CHECK_EA()      { if( (R.PC&0xFF00) != (EA&0xFF00) ) ADD_CYCLE(1); }</span><br>
<span>//#define      CHECK_EA()      {}</span><br>
<span>// フラグ操作</span><br>
<span>// ゼロ／ネガティブフラグのチェックと設定</span><br>
<span>#define      SET_ZN_FLAG(A)      { R.P &= ~(Z_FLAG|N_FLAG); R.P |= ZN_Table[(BYTE)(A)]; }</span><br>
<span>// フラグセット</span><br>
<span>#define      SET_FLAG(V)      { R.P |=(V); }</span><br>
<span>// フラグクリア</span><br>
<span>#define      CLR_FLAG(V)      { R.P &= ~(V); }</span><br>
<span>// フラグテスト＆セット／クリア</span><br>
<span>#define      TST_FLAG(F,V)      { R.P &= ~(V); if((F)) R.P |= (V); }</span><br>
<span>// フラグチェック</span><br>
<span>#define      CHK_FLAG(V)      (R.P&(V))</span><br>
<span>// WT .... WORD TEMP</span><br>
<span>// EA .... EFFECTIVE ADDRESS</span><br>
<span>// ET .... EFFECTIVE ADDRESS TEMP</span><br>
<span>// DT .... DATA</span><br>
<span>#define      MR_IM()      {                \</span><br>
<span>      DT = OP6502( R.PC++ );      \</span><br>
<span>}</span><br>
<span>#define      MR_ZP()      {                \</span><br>
<span>      EA = OP6502( R.PC++ );      \</span><br>
<span>      DT = ZPRD( EA );      \</span><br>
<span>}</span><br>
<span>#define      MR_ZX()      {                \</span><br>
<span>      DT = OP6502( R.PC++ );      \</span><br>
<span>      EA = (BYTE)(DT + R.X);      \</span><br>
<span>      DT = ZPRD( EA );      \</span><br>
<span>}</span><br>
<span>#define      MR_ZY()      {                \</span><br>
<span>      DT = OP6502( R.PC++ );      \</span><br>
<span>      EA = (BYTE)(DT + R.Y);      \</span><br>
<span>      DT = ZPRD( EA );      \</span><br>
<span>}</span><br>
<span>#define      MR_AB()      {                \</span><br>
<span>      EA = OP6502W( R.PC );      \</span><br>
<span>      R.PC += 2;                \</span><br>
<span>      DT = RD6502( EA );      \</span><br>
<span>}</span><br>
<span>#define      MR_AX()      {                \</span><br>
<span>      ET = OP6502W( R.PC );      \</span><br>
<span>      R.PC += 2;                \</span><br>
<span>      EA = ET + R.X;                \</span><br>
<span>      DT = RD6502( EA );      \</span><br>
<span>}</span><br>
<span>#define      MR_AY()      {                \</span><br>
<span>      ET = OP6502W( R.PC );      \</span><br>
<span>      R.PC += 2;                \</span><br>
<span>      EA = ET + R.Y;                \</span><br>
<span>      DT = RD6502( EA );      \</span><br>
<span>}</span><br>
<span>#define      MR_IX()      {                \</span><br>
<span>      DT = OP6502( R.PC++ );      \</span><br>
<span>      EA = ZPRDW( DT + R.X );      \</span><br>
<span>      DT = RD6502( EA );      \</span><br>
<span>}</span><br>
<span>#define      MR_IY()      {                \</span><br>
<span>      DT = OP6502( R.PC++ );      \</span><br>
<span>      ET = ZPRDW( DT );      \</span><br>
<span>      EA = ET + R.Y;                \</span><br>
<span>      DT = RD6502( EA );      \</span><br>
<span>}</span><br>
<span>// EFFECTIVE ADDRESS</span><br>
<span>#define      EA_ZP()      {                \</span><br>
<span>      EA = OP6502( R.PC++ );      \</span><br>
<span>}</span><br>
<span>#define      EA_ZX()      {                \</span><br>
<span>      DT = OP6502( R.PC++ );      \</span><br>
<span>      EA = (BYTE)(DT + R.X);      \</span><br>
<span>}</span><br>
<span>#define      EA_ZY()      {                \</span><br>
<span>      DT = OP6502( R.PC++ );      \</span><br>
<span>      EA = (BYTE)(DT + R.Y);      \</span><br>
<span>}</span><br>
<span>#define      EA_AB()      {                \</span><br>
<span>      EA = OP6502W( R.PC );      \</span><br>
<span>      R.PC += 2;                \</span><br>
<span>}</span><br>
<span>#define      EA_AX()      {                \</span><br>
<span>      ET = OP6502W( R.PC );      \</span><br>
<span>      R.PC += 2;                \</span><br>
<span>      EA = ET + R.X;                \</span><br>
<span>}</span><br>
<span>#define      EA_AY()      {                \</span><br>
<span>      ET = OP6502W( R.PC );      \</span><br>
<span>      R.PC += 2;                \</span><br>
<span>      EA = ET + R.Y;                \</span><br>
<span>}</span><br>
<span>#define      EA_IX()      {                \</span><br>
<span>      DT = OP6502( R.PC++ );      \</span><br>
<span>      EA = ZPRDW( DT + R.X );      \</span><br>
<span>}</span><br>
<span>#define      EA_IY()      {                \</span><br>
<span>      DT = OP6502( R.PC++ );      \</span><br>
<span>      ET = ZPRDW( DT );      \</span><br>
<span>      EA = ET + (WORD)R.Y;      \</span><br>
<span>}</span><br>
<span>// メモリライト</span><br>
<span>#define      MW_ZP()                ZPWR(EA,DT)</span><br>
<span>#define      MW_EA()                WR6502(EA,DT)</span><br>
<span>// STACK操作</span><br>
<span>#define      PUSH(V)                { STACK[(R.S--)&0xFF]=(V); }</span><br>
<span>#define      POP()                STACK[(++R.S)&0xFF]</span><br>
<span>// 算術演算系</span><br>
<span>/* ADC (NV----ZC) */</span><br>
<span>#define      ADC() {                                                      \</span><br>
<span>      WT = R.A+DT+(R.P&C_FLAG);                              \</span><br>
<span>      TST_FLAG( WT > 0xFF, C_FLAG );                              \</span><br>
<span>      TST_FLAG( ((~(R.A^DT))&(R.A^WT)&0x80), V_FLAG );      \</span><br>
<span>      R.A = (BYTE)WT;                                                \</span><br>
<span>      SET_ZN_FLAG(R.A);                                        \</span><br>
<span>}</span><br>
<span>/* SBC (NV----ZC) */</span><br>
<span>#define      SBC() {                                                \</span><br>
<span>      WT = R.A-DT-(~R.P&C_FLAG);                        \</span><br>
<span>      TST_FLAG( ((R.A^DT) & (R.A^WT)&0x80), V_FLAG );      \</span><br>
<span>      TST_FLAG( WT < 0x100, C_FLAG );                        \</span><br>
<span>      R.A = (BYTE)WT;                                        \</span><br>
<span>      SET_ZN_FLAG(R.A);                              \</span><br>
<span>}</span><br>
<span>/* INC (N-----Z-) */</span><br>
<span>#define      INC() {                        \</span><br>
<span>      DT++;                        \</span><br>
<span>      SET_ZN_FLAG(DT);      \</span><br>
<span>}</span><br>
<span>/* INX (N-----Z-) */</span><br>
<span>#define      INX() {                        \</span><br>
<span>      R.X++;                        \</span><br>
<span>      SET_ZN_FLAG(R.X);      \</span><br>
<span>}</span><br>
<span>/* INY (N-----Z-) */</span><br>
<span>#define      INY() {                        \</span><br>
<span>      R.Y++;                        \</span><br>
<span>      SET_ZN_FLAG(R.Y);      \</span><br>
<span>}</span><br>
<span>/* DEC (N-----Z-) */</span><br>
<span>#define      DEC() {                        \</span><br>
<span>      DT--;                        \</span><br>
<span>      SET_ZN_FLAG(DT);      \</span><br>
<span>}</span><br>
<span>/* DEX (N-----Z-) */</span><br>
<span>#define      DEX() {                        \</span><br>
<span>      R.X--;                        \</span><br>
<span>      SET_ZN_FLAG(R.X);      \</span><br>
<span>}</span><br>
<span>/* DEY (N-----Z-) */</span><br>
<span>#define      DEY() {                        \</span><br>
<span>      R.Y--;                        \</span><br>
<span>      SET_ZN_FLAG(R.Y);      \</span><br>
<span>}</span><br>
<span>// 論理演算系</span><br>
<span>/* AND (N-----Z-) */</span><br>
<span>#define      AND() {                        \</span><br>
<span>      R.A &= DT;                \</span><br>
<span>      SET_ZN_FLAG(R.A);      \</span><br>
<span>}</span><br>
<span>/* ORA (N-----Z-) */</span><br>
<span>#define      ORA() {                        \</span><br>
<span>      R.A |= DT;                \</span><br>
<span>      SET_ZN_FLAG(R.A);      \</span><br>
<span>}</span><br>
<span>/* EOR (N-----Z-) */</span><br>
<span>#define      EOR() {                        \</span><br>
<span>      R.A ^= DT;                \</span><br>
<span>      SET_ZN_FLAG(R.A);      \</span><br>
<span>}</span><br>
<span>/* ASL_A (N-----ZC) */</span><br>
<span>#define      ASL_A() {                        \</span><br>
<span>      TST_FLAG( R.A&0x80, C_FLAG );      \</span><br>
<span>      R.A <<= 1;                        \</span><br>
<span>      SET_ZN_FLAG(R.A);                \</span><br>
<span>}</span><br>
<span>/* ASL (N-----ZC) */</span><br>
<span>#define      ASL() {                              \</span><br>
<span>      TST_FLAG( DT&0x80, C_FLAG );      \</span><br>
<span>      DT <<= 1;                        \</span><br>
<span>      SET_ZN_FLAG(DT);                \</span><br>
<span>}</span><br>
<span>/* LSR_A (N-----ZC) */</span><br>
<span>#define      LSR_A() {                        \</span><br>
<span>      TST_FLAG( R.A&0x01, C_FLAG );      \</span><br>
<span>      R.A >>= 1;                        \</span><br>
<span>      SET_ZN_FLAG(R.A);                \</span><br>
<span>}</span><br>
<span>/* LSR (N-----ZC) */</span><br>
<span>#define      LSR() {                              \</span><br>
<span>      TST_FLAG( DT&0x01, C_FLAG );      \</span><br>
<span>      DT >>= 1;                        \</span><br>
<span>      SET_ZN_FLAG(DT);                \</span><br>
<span>}</span><br>
<span>/* ROL_A (N-----ZC) */</span><br>
<span>#define      ROL_A() {                              \</span><br>
<span>      if( R.P & C_FLAG ) {                        \</span><br>
<span>                TST_FLAG(R.A&0x80,C_FLAG);      \</span><br>
<span>                R.A = (R.A<<1)|0x01;                \</span><br>
<span>      } else {                              \</span><br>
<span>                TST_FLAG(R.A&0x80,C_FLAG);      \</span><br>
<span>                R.A <<= 1;                        \</span><br>
<span>      }                                        \</span><br>
<span>      SET_ZN_FLAG(R.A);                        \</span><br>
<span>}</span><br>
<span>/* ROL (N-----ZC) */</span><br>
<span>#define      ROL() {                                        \</span><br>
<span>      if( R.P & C_FLAG ) {                        \</span><br>
<span>                TST_FLAG(DT&0x80,C_FLAG);      \</span><br>
<span>                DT = (DT<<1)|0x01;                \</span><br>
<span>      } else {                              \</span><br>
<span>                TST_FLAG(DT&0x80,C_FLAG);      \</span><br>
<span>                DT <<= 1;                        \</span><br>
<span>      }                                        \</span><br>
<span>      SET_ZN_FLAG(DT);                        \</span><br>
<span>}</span><br>
<span>/* ROR_A (N-----ZC) */</span><br>
<span>#define      ROR_A() {                              \</span><br>
<span>      if( R.P & C_FLAG ) {                        \</span><br>
<span>                TST_FLAG(R.A&0x01,C_FLAG);      \</span><br>
<span>                R.A = (R.A>>1)|0x80;                \</span><br>
<span>      } else {                              \</span><br>
<span>                TST_FLAG(R.A&0x01,C_FLAG);      \</span><br>
<span>                R.A >>= 1;                        \</span><br>
<span>      }                                        \</span><br>
<span>      SET_ZN_FLAG(R.A);                        \</span><br>
<span>}</span><br>
<span>/* ROR (N-----ZC) */</span><br>
<span>#define      ROR() {                                        \</span><br>
<span>      if( R.P & C_FLAG ) {                        \</span><br>
<span>                TST_FLAG(DT&0x01,C_FLAG);      \</span><br>
<span>                DT = (DT>>1)|0x80;                \</span><br>
<span>      } else {                              \</span><br>
<span>                TST_FLAG(DT&0x01,C_FLAG);      \</span><br>
<span>                DT >>= 1;                        \</span><br>
<span>      }                                        \</span><br>
<span>      SET_ZN_FLAG(DT);                        \</span><br>
<span>}</span><br>
<span>/* BIT (NV----Z-) */</span><br>
<span>#define      BIT() {                                        \</span><br>
<span>      TST_FLAG( (DT&R.A)==0, Z_FLAG );      \</span><br>
<span>      TST_FLAG( DT&0x80, N_FLAG );                \</span><br>
<span>      TST_FLAG( DT&0x40, V_FLAG );                \</span><br>
<span>}</span><br>
<span>// ロード／ストア系</span><br>
<span>/* LDA (N-----Z-) */</span><br>
<span>#define      LDA()      { R.A = DT; SET_ZN_FLAG(R.A); }</span><br>
<span>/* LDX (N-----Z-) */</span><br>
<span>#define      LDX()      { R.X = DT; SET_ZN_FLAG(R.X); }</span><br>
<span>/* LDY (N-----Z-) */</span><br>
<span>#define      LDY()      { R.Y = DT; SET_ZN_FLAG(R.Y); }</span><br>
<span>/* STA (--------) */</span><br>
<span>#define      STA()      { DT = R.A; }</span><br>
<span>/* STX (--------) */</span><br>
<span>#define      STX()      { DT = R.X; }</span><br>
<span>/* STY (--------) */</span><br>
<span>#define      STY()      { DT = R.Y; }</span><br>
<span>/* TAX (N-----Z-) */</span><br>
<span>#define      TAX()      { R.X = R.A; SET_ZN_FLAG(R.X); }</span><br>
<span>/* TXA (N-----Z-) */</span><br>
<span>#define      TXA()      { R.A = R.X; SET_ZN_FLAG(R.A); }</span><br>
<span>/* TAY (N-----Z-) */</span><br>
<span>#define      TAY()      { R.Y = R.A; SET_ZN_FLAG(R.Y); }</span><br>
<span>/* TYA (N-----Z-) */</span><br>
<span>#define      TYA()      { R.A = R.Y; SET_ZN_FLAG(R.A); }</span><br>
<span>/* TSX (N-----Z-) */</span><br>
<span>#define      TSX()      { R.X = R.S; SET_ZN_FLAG(R.X); }</span><br>
<span>/* TXS (--------) */</span><br>
<span>#define      TXS()      { R.S = R.X; }</span><br>
<span>// 比較系</span><br>
<span>/* CMP (N-----ZC) */</span><br>
<span>#define      CMP_() {                              \</span><br>
<span>      WT = (WORD)R.A - (WORD)DT;                \</span><br>
<span>      TST_FLAG( (WT&0x8000)==0, C_FLAG );      \</span><br>
<span>      SET_ZN_FLAG( (BYTE)WT );                \</span><br>
<span>}</span><br>
<span>/* CPX (N-----ZC) */</span><br>
<span>#define      CPX() {                                        \</span><br>
<span>      WT = (WORD)R.X - (WORD)DT;                \</span><br>
<span>      TST_FLAG( (WT&0x8000)==0, C_FLAG );      \</span><br>
<span>      SET_ZN_FLAG( (BYTE)WT );                \</span><br>
<span>}</span><br>
<span>/* CPY (N-----ZC) */</span><br>
<span>#define      CPY() {                                        \</span><br>
<span>      WT = (WORD)R.Y - (WORD)DT;                \</span><br>
<span>      TST_FLAG( (WT&0x8000)==0, C_FLAG );      \</span><br>
<span>      SET_ZN_FLAG( (BYTE)WT );                \</span><br>
<span>}</span><br>
<span>// ジャンプ／リターン系</span><br>
<span>#if      1</span><br>
<span>#define      JMP_ID() {                              \</span><br>
<span>      WT = OP6502W(R.PC);                        \</span><br>
<span>      EA = RD6502(WT);                        \</span><br>
<span>      WT = (WT&0xFF00)|((WT+1)&0x00FF);      \</span><br>
<span>      R.PC = EA+RD6502(WT)*0x100;                \</span><br>
<span>}</span><br>
<span>#else</span><br>
<span>#define      JMP_ID() {                \</span><br>
<span>      ET = OP6502W(R.PC);      \</span><br>
<span>      EA = RD6502W(ET);      \</span><br>
<span>      R.PC = EA;                \</span><br>
<span>}</span><br>
<span>#endif</span><br>
<span>#define      JMP() {                        \</span><br>
<span>      R.PC = OP6502W( R.PC );      \</span><br>
<span>}</span><br>
<span>#define      JSR() {                        \</span><br>
<span>      EA = OP6502W( R.PC );      \</span><br>
<span>      R.PC++;                        \</span><br>
<span>      PUSH( R.PC>>8 );      \</span><br>
<span>      PUSH( R.PC&0xFF );      \</span><br>
<span>      R.PC = EA;                \</span><br>
<span>}</span><br>
<span>#define      RTS() {                        \</span><br>
<span>      R.PC= POP();                \</span><br>
<span>      R.PC |= POP()*0x0100;      \</span><br>
<span>      R.PC++;                        \</span><br>
<span>}</span><br>
<span>#define      RTI() {                        \</span><br>
<span>      R.P   = POP() | R_FLAG;      \</span><br>
<span>      R.PC= POP();                \</span><br>
<span>      R.PC |= POP()*0x0100;      \</span><br>
<span>}</span><br>
<span>#define      _NMI() {                        \</span><br>
<span>      PUSH( R.PC>>8 );                \</span><br>
<span>      PUSH( R.PC&0xFF );                \</span><br>
<span>      CLR_FLAG( B_FLAG );                \</span><br>
<span>      PUSH( R.P );                        \</span><br>
<span>      SET_FLAG( I_FLAG );                \</span><br>
<span>      R.PC = RD6502W(NMI_VECTOR);      \</span><br>
<span>      exec_cycles += 7;                \</span><br>
<span>}</span><br>
<span>#define      _IRQ() {                        \</span><br>
<span>      PUSH( R.PC>>8 );                \</span><br>
<span>      PUSH( R.PC&0xFF );                \</span><br>
<span>      CLR_FLAG( B_FLAG );                \</span><br>
<span>      PUSH( R.P );                        \</span><br>
<span>      SET_FLAG( I_FLAG );                \</span><br>
<span>      R.PC = RD6502W(IRQ_VECTOR);      \</span><br>
<span>      exec_cycles += 7;                \</span><br>
<span>}</span><br>
<span>#define      BRK() {                              \</span><br>
<span>      R.PC++;                              \</span><br>
<span>      PUSH( R.PC>>8 );                \</span><br>
<span>      PUSH( R.PC&0xFF );                \</span><br>
<span>      SET_FLAG( B_FLAG );                \</span><br>
<span>      PUSH( R.P );                        \</span><br>
<span>      SET_FLAG( I_FLAG );                \</span><br>
<span>      R.PC = RD6502W(IRQ_VECTOR);      \</span><br>
<span>}</span><br>
<span>#if      1</span><br>
<span>#define      REL_JUMP() {                \</span><br>
<span>      ET = R.PC;                \</span><br>
<span>      EA = R.PC + (SBYTE)DT;      \</span><br>
<span>      R.PC = EA;                \</span><br>
<span>      ADD_CYCLE(1);                \</span><br>
<span>      CHECK_EA();                \</span><br>
<span>}</span><br>
<span>#else</span><br>
<span>#define      REL_JUMP() {                        \</span><br>
<span>      R.PC = R.PC + (SBYTE)DT;      \</span><br>
<span>      ADD_CYCLE(1);                        \</span><br>
<span>}</span><br>
<span>#endif</span><br>
<span>#define      BCC()      { if( !(R.P & C_FLAG) ) REL_JUMP(); }</span><br>
<span>#define      BCS()      { if((R.P & C_FLAG) ) REL_JUMP(); }</span><br>
<span>#define      BNE()      { if( !(R.P & Z_FLAG) ) REL_JUMP(); }</span><br>
<span>#define      BEQ()      { if((R.P & Z_FLAG) ) REL_JUMP(); }</span><br>
<span>#define      BPL()      { if( !(R.P & N_FLAG) ) REL_JUMP(); }</span><br>
<span>#define      BMI()      { if((R.P & N_FLAG) ) REL_JUMP(); }</span><br>
<span>#define      BVC()      { if( !(R.P & V_FLAG) ) REL_JUMP(); }</span><br>
<span>#define      BVS()      { if((R.P & V_FLAG) ) REL_JUMP(); }</span><br>
<span>// フラグ制御系</span><br>
<span>#define      CLC()      { R.P &= ~C_FLAG; }</span><br>
<span>#define      CLD()      { R.P &= ~D_FLAG; }</span><br>
<span>#define      CLI()      { R.P &= ~I_FLAG; }</span><br>
<span>#define      CLV()      { R.P &= ~V_FLAG; }</span><br>
<span>#define      SEC()      { R.P |= C_FLAG; }</span><br>
<span>#define      SED()      { R.P |= D_FLAG; }</span><br>
<span>#define      SEI()      { R.P |= I_FLAG; }</span><br>
<span>// Unofficial命令</span><br>
<span>#define      ANC()      {                        \</span><br>
<span>      R.A &= DT;                        \</span><br>
<span>      SET_ZN_FLAG( R.A );                \</span><br>
<span>      TST_FLAG( R.P&N_FLAG, C_FLAG );      \</span><br>
<span>}</span><br>
<span>#define      ANE()      {                        \</span><br>
<span>      R.A = (R.A|0xEE)&R.X&DT;      \</span><br>
<span>      SET_ZN_FLAG( R.A );                \</span><br>
<span>}</span><br>
<span>#define      ARR()      {                              \</span><br>
<span>      DT &= R.A;                              \</span><br>
<span>      R.A = (DT>>1)|((R.P&C_FLAG)<<7);      \</span><br>
<span>      SET_ZN_FLAG( R.A );                        \</span><br>
<span>      TST_FLAG( R.A&0x40, C_FLAG );                \</span><br>
<span>      TST_FLAG( (R.A>>6)^(R.A>>5), V_FLAG );      \</span><br>
<span>}</span><br>
<span>#define      ASR()      {                        \</span><br>
<span>      DT &= R.A;                        \</span><br>
<span>      TST_FLAG( DT&0x01, C_FLAG );      \</span><br>
<span>      R.A = DT>>1;                        \</span><br>
<span>      SET_ZN_FLAG( R.A );                \</span><br>
<span>}</span><br>
<span>#define      DCP()      {                        \</span><br>
<span>      DT--;                              \</span><br>
<span>      CMP_();                              \</span><br>
<span>}</span><br>
<span>#define      DOP()      {                        \</span><br>
<span>      R.PC++;                              \</span><br>
<span>}</span><br>
<span>#define      ISB()      {                        \</span><br>
<span>      DT++;                              \</span><br>
<span>      SBC();                              \</span><br>
<span>}</span><br>
<span>#define      LAS()      {                        \</span><br>
<span>      R.A = R.X = R.S = (R.S & DT);      \</span><br>
<span>      SET_ZN_FLAG( R.A );                \</span><br>
<span>}</span><br>
<span>#define      LAX()      {                        \</span><br>
<span>      R.A = DT;                        \</span><br>
<span>      R.X = R.A;                        \</span><br>
<span>      SET_ZN_FLAG( R.A );                \</span><br>
<span>}</span><br>
<span>#define      LXA()      {                        \</span><br>
<span>      R.A = R.X = ((R.A|0xEE)&DT);      \</span><br>
<span>      SET_ZN_FLAG( R.A );                \</span><br>
<span>}</span><br>
<span>#define      RLA()      {                              \</span><br>
<span>      if( R.P & C_FLAG ) {                        \</span><br>
<span>                TST_FLAG( DT&0x80, C_FLAG );      \</span><br>
<span>                DT = (DT<<1)|1;                        \</span><br>
<span>      } else {                              \</span><br>
<span>                TST_FLAG( DT&0x80, C_FLAG );      \</span><br>
<span>                DT <<= 1;                        \</span><br>
<span>      }                                        \</span><br>
<span>      R.A &= DT;                              \</span><br>
<span>      SET_ZN_FLAG( R.A );                        \</span><br>
<span>}</span><br>
<span>#define      RRA()      {                              \</span><br>
<span>      if( R.P & C_FLAG ) {                        \</span><br>
<span>                TST_FLAG( DT&0x01, C_FLAG );      \</span><br>
<span>                DT = (DT>>1)|0x80;                \</span><br>
<span>      } else {                              \</span><br>
<span>                TST_FLAG( DT&0x01, C_FLAG );      \</span><br>
<span>                DT >>= 1;                        \</span><br>
<span>      }                                        \</span><br>
<span>      ADC();                                        \</span><br>
<span>}</span><br>
<span>#define      SAX()      {                        \</span><br>
<span>      DT = R.A & R.X;                        \</span><br>
<span>}</span><br>
<span>#define      SBX()      {                        \</span><br>
<span>      WT = (R.A&R.X)-DT;                \</span><br>
<span>      TST_FLAG( WT < 0x100, C_FLAG );      \</span><br>
<span>      R.X = WT&0xFF;                        \</span><br>
<span>      SET_ZN_FLAG( R.X );                \</span><br>
<span>}</span><br>
<span>#define      SHA()      {                              \</span><br>
<span>      DT = R.A & R.X & (BYTE)((EA>>8)+1);      \</span><br>
<span>}</span><br>
<span>#define      SHS()      {                        \</span><br>
<span>      R.S = R.A & R.X;                \</span><br>
<span>      DT = R.S & (BYTE)((EA>>8)+1);      \</span><br>
<span>}</span><br>
<span>#define      SHX()      {                        \</span><br>
<span>      DT = R.X & (BYTE)((EA>>8)+1);      \</span><br>
<span>}</span><br>
<span>#define      SHY()      {                        \</span><br>
<span>      DT = R.Y & (BYTE)((EA>>8)+1);      \</span><br>
<span>}</span><br>
<span>#define      SLO()      {                        \</span><br>
<span>      TST_FLAG( DT&0x80, C_FLAG );      \</span><br>
<span>      DT <<= 1;                        \</span><br>
<span>      R.A |= DT;                        \</span><br>
<span>      SET_ZN_FLAG( R.A );                \</span><br>
<span>}</span><br>
<span>#define      SRE()      {                        \</span><br>
<span>      TST_FLAG( DT&0x01, C_FLAG );      \</span><br>
<span>      DT >>= 1;                        \</span><br>
<span>      R.A ^= DT;                        \</span><br>
<span>      SET_ZN_FLAG( R.A );                \</span><br>
<span>}</span><br>
<span>#define      TOP()      {                        \</span><br>
<span>      R.PC += 2;                        \</span><br>
<span>}</span><br>
<span>//</span><br>
<span>// コンストラクタ/デストラクタ</span><br>
<span>//</span><br>
<span>//CPU::CPU( NES* parent )</span><br>
<span>CPU::CPU( NES* parent ) : nes(parent)</span><br>
<span>{</span><br>
<span>//      nes = parent;</span><br>
<span>      m_bClockProcess = FALSE;</span><br>
<span>}</span><br>
<span>CPU::~CPU()</span><br>
<span>{</span><br>
<span>}</span><br>
<span>// メモリアクセス</span><br>
<span>//#define      OP6502(A)      (CPU_MEM_BANK[(A)>>13][(A)&0x1FFF])</span><br>
<span>//#define      OP6502W(A)      (*((WORD*)&CPU_MEM_BANK[(A)>>13][(A)&0x1FFF]))</span><br>
<span>#if      0</span><br>
<span>#define      OP6502(A)      RD6502((A))</span><br>
<span>#define      OP6502W(A)      RD6502W((A))</span><br>
<span>#else</span><br>
<span>inline      BYTE      OP6502( WORD addr )</span><br>
<span>{</span><br>
<span>      return      CPU_MEM_BANK;</span><br>
<span>}</span><br>
<span>inline      WORD      OP6502W( WORD addr )</span><br>
<span>{</span><br>
<span>#if      0</span><br>
<span>      WORD      ret;</span><br>
<span>      ret= (WORD)CPU_MEM_BANK[(addr+0)>>13][(addr+0)&0x1FFF];</span><br>
<span>      ret |= (WORD)CPU_MEM_BANK[(addr+1)>>13][(addr+1)&0x1FFF]<<8;</span><br>
<span>      return      ret;</span><br>
<span>#else</span><br>
<span>      return      *((WORD*)&CPU_MEM_BANK);</span><br>
<span>#endif</span><br>
<span>}</span><br>
<span>#endif</span><br>
<span>inline      BYTE      CPU::RD6502( WORD addr )</span><br>
<span>{</span><br>
<span>      if( addr < 0x2000 ) {</span><br>
<span>      // RAM (Mirror $0800, $1000, $1800)</span><br>
<span>                return      RAM;</span><br>
<span>      } else if( addr < 0x8000 ) {</span><br>
<span>      // Others</span><br>
<span>                return      nes->Read( addr );</span><br>
<span>      } else {</span><br>
<span>      // Dummy access</span><br>
<span>                mapper->Read( addr, CPU_MEM_BANK );</span><br>
<span>      }</span><br>
<span>      // Quick bank read</span><br>
<span>      return      CPU_MEM_BANK;</span><br>
<span>}</span><br>
<span>inline      WORD      CPU::RD6502W( WORD addr )</span><br>
<span>{</span><br>
<span>      if( addr < 0x2000 ) {</span><br>
<span>      // RAM (Mirror $0800, $1000, $1800)</span><br>
<span>                return      *((WORD*)&RAM);</span><br>
<span>      } else if( addr < 0x8000 ) {</span><br>
<span>      // Others</span><br>
<span>                return      (WORD)nes->Read(addr)+(WORD)nes->Read(addr+1)*0x100;</span><br>
<span>      }</span><br>
<span>      // Quick bank read</span><br>
<span>#if      0</span><br>
<span>      WORD      ret;</span><br>
<span>      ret= (WORD)CPU_MEM_BANK[(addr+0)>>13][(addr+0)&0x1FFF];</span><br>
<span>      ret |= (WORD)CPU_MEM_BANK[(addr+1)>>13][(addr+1)&0x1FFF]<<8;</span><br>
<span>      return      ret;</span><br>
<span>#else</span><br>
<span>      return      *((WORD*)&CPU_MEM_BANK);</span><br>
<span>#endif</span><br>
<span>}</span><br>
<span>// メモリライト</span><br>
<span>inline      void      CPU::WR6502( WORD addr, BYTE data )</span><br>
<span>{</span><br>
<span>      if( addr < 0x2000 ) {</span><br>
<span>      // RAM (Mirror $0800, $1000, $1800)</span><br>
<span>                RAM = data;</span><br>
<span>      } else {</span><br>
<span>      // Others</span><br>
<span>                nes->Write( addr, data );</span><br>
<span>      }</span><br>
<span>}</span><br>
<span>//</span><br>
<span>// リセット</span><br>
<span>//</span><br>
<span>void      CPU::Reset()</span><br>
<span>{</span><br>
<span>      apu = nes->apu;</span><br>
<span>      mapper = nes->mapper;</span><br>
<span>      R.A= 0x00;</span><br>
<span>      R.X= 0x00;</span><br>
<span>      R.Y= 0x00;</span><br>
<span>      R.S= 0xFF;</span><br>
<span>      R.P= Z_FLAG|R_FLAG;</span><br>
<span>      R.PC = RD6502W(RES_VECTOR);</span><br>
<span>      R.INT_pending = 0;</span><br>
<span>      TOTAL_cycles = 0;</span><br>
<span>      DMA_cycles = 0;</span><br>
<span>      // STACK quick access</span><br>
<span>      STACK = &RAM;</span><br>
<span>      // Zero/Negative FLAG</span><br>
<span>      ZN_Table = Z_FLAG;</span><br>
<span>      for( INT i = 1; i < 256; i++ )</span><br>
<span>                ZN_Table = (i & 0x80)?N_FLAG:0;</span><br>
<span>}</span><br>
<span>INT      CPU::GetDmaCycles()</span><br>
<span>{</span><br>
<span>      return      DMA_cycles;</span><br>
<span>}</span><br>
<span>void      CPU::SetDmaCycles( INT cycles )</span><br>
<span>{</span><br>
<span>      DMA_cycles = cycles;</span><br>
<span>}</span><br>
<span>INT      CPU::GetTotalCycles()</span><br>
<span>{</span><br>
<span>      return      TOTAL_cycles;</span><br>
<span>}</span><br>
<span>void      CPU::SetTotalCycles( INT cycles )</span><br>
<span>{</span><br>
<span>      TOTAL_cycles = cycles;</span><br>
<span>}</span><br>
<span>//</span><br>
<span>// DMAペンディングサイクル設定</span><br>
<span>//</span><br>
<span>void      CPU::DMA( INT cycles )</span><br>
<span>{</span><br>
<span>      DMA_cycles += cycles;</span><br>
<span>}</span><br>
<span>static      int      nmicount;</span><br>
<span>//</span><br>
<span>// 割り込み</span><br>
<span>//</span><br>
<span>void      CPU::NMI()</span><br>
<span>{</span><br>
<span>      R.INT_pending |= NMI_FLAG;</span><br>
<span>      nmicount = 0;</span><br>
<span>}</span><br>
<span>void      CPU::SetIRQ( BYTE mask )</span><br>
<span>{</span><br>
<span>      R.INT_pending |= mask;</span><br>
<span>}</span><br>
<span>void      CPU::ClrIRQ( BYTE mask )</span><br>
<span>{</span><br>
<span>      R.INT_pending &= ~mask;</span><br>
<span>}</span><br>
<span>//</span><br>
<span>// 命令実行</span><br>
<span>//</span><br>
<span>INT      CPU::EXEC( INT request_cycles )</span><br>
<span>{</span><br>
<span>BYTE      opcode;                // オペコード</span><br>
<span>INT      OLD_cycles = TOTAL_cycles;</span><br>
<span>INT      exec_cycles;</span><br>
<span>BYTE      nmi_request, irq_request;</span><br>
<span>BOOL      bClockProcess = m_bClockProcess;</span><br>
<span>// TEMP</span><br>
<span>register WORD      EA;</span><br>
<span>register WORD      ET;</span><br>
<span>register WORD      WT;</span><br>
<span>register BYTE      DT;</span><br>
<span>      while( request_cycles > 0 ) {</span><br>
<span>                exec_cycles = 0;</span><br>
<span>                if( DMA_cycles ) {</span><br>
<span>                        if( request_cycles <= DMA_cycles ) {</span><br>
<span>                              DMA_cycles -= request_cycles;</span><br>
<span>                              TOTAL_cycles += request_cycles;</span><br>
<span>                              // クロック同期処理</span><br>
<span>                              mapper->Clock( request_cycles );</span><br>
<span>#if      DPCM_SYNCCLOCK</span><br>
<span>                              apu->SyncDPCM( request_cycles );</span><br>
<span>#endif</span><br>
<span>                              if( bClockProcess ) {</span><br>
<span>                                        nes->Clock( request_cycles );</span><br>
<span>                              }</span><br>
<span>//                              nes->Clock( request_cycles );</span><br>
<span>                              goto      _execute_exit;</span><br>
<span>                        } else {</span><br>
<span>                              exec_cycles += DMA_cycles;</span><br>
<span>//                              request_cycles -= DMA_cycles;</span><br>
<span>                              DMA_cycles = 0;</span><br>
<span>                        }</span><br>
<span>                }</span><br>
<span>                nmi_request = irq_request = 0;</span><br>
<span>                opcode = OP6502( R.PC++ );</span><br>
<span>                if( R.INT_pending ) {</span><br>
<span>                        if( R.INT_pending & NMI_FLAG ) {</span><br>
<span>                              nmi_request = 0xFF;</span><br>
<span>                              R.INT_pending &= ~NMI_FLAG;</span><br>
<span>                        } else</span><br>
<span>                        if( R.INT_pending & IRQ_MASK ) {</span><br>
<span>                              R.INT_pending &= ~IRQ_TRIGGER2;</span><br>
<span>                              if( !(R.P & I_FLAG) && opcode != 0x40 ) {</span><br>
<span>                                        irq_request = 0xFF;</span><br>
<span>                                        R.INT_pending &= ~IRQ_TRIGGER;</span><br>
<span>                              }</span><br>
<span>                        }</span><br>
<span>                }</span><br>
<span>                switch( opcode ) {</span><br>
<span>                        case      0x69: // ADC #$??</span><br>
<span>                              MR_IM(); ADC();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0x65: // ADC $??</span><br>
<span>                              MR_ZP(); ADC();</span><br>
<span>                              ADD_CYCLE(3);</span><br>
<span>                              break;</span><br>
<span>                        case      0x75: // ADC $??,X</span><br>
<span>                              MR_ZX(); ADC();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0x6D: // ADC $????</span><br>
<span>                              MR_AB(); ADC();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0x7D: // ADC $????,X</span><br>
<span>                              MR_AX(); ADC(); CHECK_EA();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0x79: // ADC $????,Y</span><br>
<span>                              MR_AY(); ADC(); CHECK_EA();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0x61: // ADC ($??,X)</span><br>
<span>                              MR_IX(); ADC();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0x71: // ADC ($??),Y</span><br>
<span>                              MR_IY(); ADC(); CHECK_EA();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0xE9: // SBC #$??</span><br>
<span>                              MR_IM(); SBC();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0xE5: // SBC $??</span><br>
<span>                              MR_ZP(); SBC();</span><br>
<span>                              ADD_CYCLE(3);</span><br>
<span>                              break;</span><br>
<span>                        case      0xF5: // SBC $??,X</span><br>
<span>                              MR_ZX(); SBC();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0xED: // SBC $????</span><br>
<span>                              MR_AB(); SBC();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0xFD: // SBC $????,X</span><br>
<span>                              MR_AX(); SBC(); CHECK_EA();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0xF9: // SBC $????,Y</span><br>
<span>                              MR_AY(); SBC(); CHECK_EA();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0xE1: // SBC ($??,X)</span><br>
<span>                              MR_IX(); SBC();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0xF1: // SBC ($??),Y</span><br>
<span>                              MR_IY(); SBC(); CHECK_EA();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0xC6: // DEC $??</span><br>
<span>                              MR_ZP(); DEC();      MW_ZP();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0xD6: // DEC $??,X</span><br>
<span>                              MR_ZX(); DEC(); MW_ZP();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0xCE: // DEC $????</span><br>
<span>                              MR_AB(); DEC(); MW_EA();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0xDE: // DEC $????,X</span><br>
<span>                              MR_AX(); DEC(); MW_EA();</span><br>
<span>                              ADD_CYCLE(7);</span><br>
<span>                              break;</span><br>
<span>                        case      0xCA: // DEX</span><br>
<span>                              DEX();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0x88: // DEY</span><br>
<span>                              DEY();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0xE6: // INC $??</span><br>
<span>                              MR_ZP(); INC(); MW_ZP();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0xF6: // INC $??,X</span><br>
<span>                              MR_ZX(); INC(); MW_ZP();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0xEE: // INC $????</span><br>
<span>                              MR_AB(); INC(); MW_EA();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0xFE: // INC $????,X</span><br>
<span>                              MR_AX(); INC(); MW_EA();</span><br>
<span>                              ADD_CYCLE(7);</span><br>
<span>                              break;</span><br>
<span>                        case      0xE8: // INX</span><br>
<span>                              INX();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0xC8: // INY</span><br>
<span>                              INY();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0x29: // AND #$??</span><br>
<span>                              MR_IM(); AND();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0x25: // AND $??</span><br>
<span>                              MR_ZP(); AND();</span><br>
<span>                              ADD_CYCLE(3);</span><br>
<span>                              break;</span><br>
<span>                        case      0x35: // AND $??,X</span><br>
<span>                              MR_ZX(); AND();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0x2D: // AND $????</span><br>
<span>                              MR_AB(); AND();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0x3D: // AND $????,X</span><br>
<span>                              MR_AX(); AND(); CHECK_EA();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0x39: // AND $????,Y</span><br>
<span>                              MR_AY(); AND(); CHECK_EA();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0x21: // AND ($??,X)</span><br>
<span>                              MR_IX(); AND();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0x31: // AND ($??),Y</span><br>
<span>                              MR_IY(); AND(); CHECK_EA();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0x0A: // ASL A</span><br>
<span>                              ASL_A();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0x06: // ASL $??</span><br>
<span>                              MR_ZP(); ASL(); MW_ZP();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0x16: // ASL $??,X</span><br>
<span>                              MR_ZX(); ASL(); MW_ZP();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0x0E: // ASL $????</span><br>
<span>                              MR_AB(); ASL(); MW_EA();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0x1E: // ASL $????,X</span><br>
<span>                              MR_AX(); ASL(); MW_EA();</span><br>
<span>                              ADD_CYCLE(7);</span><br>
<span>                              break;</span><br>
<span>                        case      0x24: // BIT $??</span><br>
<span>                              MR_ZP(); BIT();</span><br>
<span>                              ADD_CYCLE(3);</span><br>
<span>                              break;</span><br>
<span>                        case      0x2C: // BIT $????</span><br>
<span>                              MR_AB(); BIT();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0x49: // EOR #$??</span><br>
<span>                              MR_IM(); EOR();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0x45: // EOR $??</span><br>
<span>                              MR_ZP(); EOR();</span><br>
<span>                              ADD_CYCLE(3);</span><br>
<span>                              break;</span><br>
<span>                        case      0x55: // EOR $??,X</span><br>
<span>                              MR_ZX(); EOR();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0x4D: // EOR $????</span><br>
<span>                              MR_AB(); EOR();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0x5D: // EOR $????,X</span><br>
<span>                              MR_AX(); EOR(); CHECK_EA();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0x59: // EOR $????,Y</span><br>
<span>                              MR_AY(); EOR(); CHECK_EA();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0x41: // EOR ($??,X)</span><br>
<span>                              MR_IX(); EOR();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0x51: // EOR ($??),Y</span><br>
<span>                              MR_IY(); EOR(); CHECK_EA();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0x4A: // LSR A</span><br>
<span>                              LSR_A();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0x46: // LSR $??</span><br>
<span>                              MR_ZP(); LSR(); MW_ZP();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0x56: // LSR $??,X</span><br>
<span>                              MR_ZX(); LSR(); MW_ZP();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0x4E: // LSR $????</span><br>
<span>                              MR_AB(); LSR(); MW_EA();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0x5E: // LSR $????,X</span><br>
<span>                              MR_AX(); LSR(); MW_EA();</span><br>
<span>                              ADD_CYCLE(7);</span><br>
<span>                              break;</span><br>
<span>                        case      0x09: // ORA #$??</span><br>
<span>                              MR_IM(); ORA();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0x05: // ORA $??</span><br>
<span>                              MR_ZP(); ORA();</span><br>
<span>                              ADD_CYCLE(3);</span><br>
<span>                              break;</span><br>
<span>                        case      0x15: // ORA $??,X</span><br>
<span>                              MR_ZX(); ORA();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0x0D: // ORA $????</span><br>
<span>                              MR_AB(); ORA();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0x1D: // ORA $????,X</span><br>
<span>                              MR_AX(); ORA(); CHECK_EA();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0x19: // ORA $????,Y</span><br>
<span>                              MR_AY(); ORA(); CHECK_EA();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0x01: // ORA ($??,X)</span><br>
<span>                              MR_IX(); ORA();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0x11: // ORA ($??),Y</span><br>
<span>                              MR_IY(); ORA(); CHECK_EA();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0x2A: // ROL A</span><br>
<span>                              ROL_A();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0x26: // ROL $??</span><br>
<span>                              MR_ZP(); ROL(); MW_ZP();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0x36: // ROL $??,X</span><br>
<span>                              MR_ZX(); ROL(); MW_ZP();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0x2E: // ROL $????</span><br>
<span>                              MR_AB(); ROL(); MW_EA();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0x3E: // ROL $????,X</span><br>
<span>                              MR_AX(); ROL(); MW_EA();</span><br>
<span>                              ADD_CYCLE(7);</span><br>
<span>                              break;</span><br>
<span>                        case      0x6A: // ROR A</span><br>
<span>                              ROR_A();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0x66: // ROR $??</span><br>
<span>                              MR_ZP(); ROR(); MW_ZP();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0x76: // ROR $??,X</span><br>
<span>                              MR_ZX(); ROR(); MW_ZP();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0x6E: // ROR $????</span><br>
<span>                              MR_AB(); ROR(); MW_EA();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0x7E: // ROR $????,X</span><br>
<span>                              MR_AX(); ROR(); MW_EA();</span><br>
<span>                              ADD_CYCLE(7);</span><br>
<span>                              break;</span><br>
<span>                        case      0xA9: // LDA #$??</span><br>
<span>                              MR_IM(); LDA();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0xA5: // LDA $??</span><br>
<span>                              MR_ZP(); LDA();</span><br>
<span>                              ADD_CYCLE(3);</span><br>
<span>                              break;</span><br>
<span>                        case      0xB5: // LDA $??,X</span><br>
<span>                              MR_ZX(); LDA();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0xAD: // LDA $????</span><br>
<span>                              MR_AB(); LDA();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0xBD: // LDA $????,X</span><br>
<span>                              MR_AX(); LDA(); CHECK_EA();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0xB9: // LDA $????,Y</span><br>
<span>                              MR_AY(); LDA(); CHECK_EA();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0xA1: // LDA ($??,X)</span><br>
<span>                              MR_IX(); LDA();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0xB1: // LDA ($??),Y</span><br>
<span>                              MR_IY(); LDA(); CHECK_EA();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0xA2: // LDX #$??</span><br>
<span>                              MR_IM(); LDX();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0xA6: // LDX $??</span><br>
<span>                              MR_ZP(); LDX();</span><br>
<span>                              ADD_CYCLE(3);</span><br>
<span>                              break;</span><br>
<span>                        case      0xB6: // LDX $??,Y</span><br>
<span>                              MR_ZY(); LDX();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0xAE: // LDX $????</span><br>
<span>                              MR_AB(); LDX();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0xBE: // LDX $????,Y</span><br>
<span>                              MR_AY(); LDX(); CHECK_EA();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0xA0: // LDY #$??</span><br>
<span>                              MR_IM(); LDY();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0xA4: // LDY $??</span><br>
<span>                              MR_ZP(); LDY();</span><br>
<span>                              ADD_CYCLE(3);</span><br>
<span>                              break;</span><br>
<span>                        case      0xB4: // LDY $??,X</span><br>
<span>                              MR_ZX(); LDY();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0xAC: // LDY $????</span><br>
<span>                              MR_AB(); LDY();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0xBC: // LDY $????,X</span><br>
<span>                              MR_AX(); LDY(); CHECK_EA();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0x85: // STA $??</span><br>
<span>                              EA_ZP(); STA(); MW_ZP();</span><br>
<span>                              ADD_CYCLE(3);</span><br>
<span>                              break;</span><br>
<span>                        case      0x95: // STA $??,X</span><br>
<span>                              EA_ZX(); STA(); MW_ZP();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0x8D: // STA $????</span><br>
<span>                              EA_AB(); STA(); MW_EA();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0x9D: // STA $????,X</span><br>
<span>                              EA_AX(); STA(); MW_EA();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0x99: // STA $????,Y</span><br>
<span>                              EA_AY(); STA(); MW_EA();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0x81: // STA ($??,X)</span><br>
<span>                              EA_IX(); STA(); MW_EA();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0x91: // STA ($??),Y</span><br>
<span>                              EA_IY(); STA(); MW_EA();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0x86: // STX $??</span><br>
<span>                              EA_ZP(); STX(); MW_ZP();</span><br>
<span>                              ADD_CYCLE(3);</span><br>
<span>                              break;</span><br>
<span>                        case      0x96: // STX $??,Y</span><br>
<span>                              EA_ZY(); STX(); MW_ZP();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0x8E: // STX $????</span><br>
<span>                              EA_AB(); STX(); MW_EA();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0x84: // STY $??</span><br>
<span>                              EA_ZP(); STY(); MW_ZP();</span><br>
<span>                              ADD_CYCLE(3);</span><br>
<span>                              break;</span><br>
<span>                        case      0x94: // STY $??,X</span><br>
<span>                              EA_ZX(); STY(); MW_ZP();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0x8C: // STY $????</span><br>
<span>                              EA_AB(); STY(); MW_EA();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0xAA: // TAX</span><br>
<span>                              TAX();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0x8A: // TXA</span><br>
<span>                              TXA();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0xA8: // TAY</span><br>
<span>                              TAY();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0x98: // TYA</span><br>
<span>                              TYA();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0xBA: // TSX</span><br>
<span>                              TSX();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0x9A: // TXS</span><br>
<span>                              TXS();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0xC9: // CMP #$??</span><br>
<span>                              MR_IM(); CMP_();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0xC5: // CMP $??</span><br>
<span>                              MR_ZP(); CMP_();</span><br>
<span>                              ADD_CYCLE(3);</span><br>
<span>                              break;</span><br>
<span>                        case      0xD5: // CMP $??,X</span><br>
<span>                              MR_ZX(); CMP_();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0xCD: // CMP $????</span><br>
<span>                              MR_AB(); CMP_();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0xDD: // CMP $????,X</span><br>
<span>                              MR_AX(); CMP_(); CHECK_EA();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0xD9: // CMP $????,Y</span><br>
<span>                              MR_AY(); CMP_(); CHECK_EA();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0xC1: // CMP ($??,X)</span><br>
<span>                              MR_IX(); CMP_();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0xD1: // CMP ($??),Y</span><br>
<span>                              MR_IY(); CMP_(); CHECK_EA();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0xE0: // CPX #$??</span><br>
<span>                              MR_IM(); CPX();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0xE4: // CPX $??</span><br>
<span>                              MR_ZP(); CPX();</span><br>
<span>                              ADD_CYCLE(3);</span><br>
<span>                              break;</span><br>
<span>                        case      0xEC: // CPX $????</span><br>
<span>                              MR_AB(); CPX();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0xC0: // CPY #$??</span><br>
<span>                              MR_IM(); CPY();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0xC4: // CPY $??</span><br>
<span>                              MR_ZP(); CPY();</span><br>
<span>                              ADD_CYCLE(3);</span><br>
<span>                              break;</span><br>
<span>                        case      0xCC: // CPY $????</span><br>
<span>                              MR_AB(); CPY();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0x90: // BCC</span><br>
<span>                              MR_IM(); BCC();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0xB0: // BCS</span><br>
<span>                              MR_IM(); BCS();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0xF0: // BEQ</span><br>
<span>                              MR_IM(); BEQ();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0x30: // BMI</span><br>
<span>                              MR_IM(); BMI();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0xD0: // BNE</span><br>
<span>                              MR_IM(); BNE();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0x10: // BPL</span><br>
<span>                              MR_IM(); BPL();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0x50: // BVC</span><br>
<span>                              MR_IM(); BVC();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0x70: // BVS</span><br>
<span>                              MR_IM(); BVS();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0x4C: // JMP $????</span><br>
<span>                              JMP();</span><br>
<span>                              ADD_CYCLE(3);</span><br>
<span>                              break;</span><br>
<span>                        case      0x6C: // JMP ($????)</span><br>
<span>                              JMP_ID();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0x20: // JSR</span><br>
<span>                              JSR();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0x40: // RTI</span><br>
<span>                              RTI();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0x60: // RTS</span><br>
<span>                              RTS();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>      // フラグ制御系</span><br>
<span>                        case      0x18: // CLC</span><br>
<span>                              CLC();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0xD8: // CLD</span><br>
<span>                              CLD();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0x58: // CLI</span><br>
<span>                              CLI();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0xB8: // CLV</span><br>
<span>                              CLV();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0x38: // SEC</span><br>
<span>                              SEC();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0xF8: // SED</span><br>
<span>                              SED();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0x78: // SEI</span><br>
<span>                              SEI();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>      // スタック系</span><br>
<span>                        case      0x48: // PHA</span><br>
<span>                              PUSH( R.A );</span><br>
<span>                              ADD_CYCLE(3);</span><br>
<span>                              break;</span><br>
<span>                        case      0x08: // PHP</span><br>
<span>                              PUSH( R.P | B_FLAG );</span><br>
<span>                              ADD_CYCLE(3);</span><br>
<span>                              break;</span><br>
<span>                        case      0x68: // PLA (N-----Z-)</span><br>
<span>                              R.A = POP();</span><br>
<span>                              SET_ZN_FLAG(R.A);</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0x28: // PLP</span><br>
<span>                              R.P = POP() | R_FLAG;</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>      // その他</span><br>
<span>                        case      0x00: // BRK</span><br>
<span>                              BRK();</span><br>
<span>                              ADD_CYCLE(7);</span><br>
<span>                              break;</span><br>
<span>                        case      0xEA: // NOP</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>      // 未公開命令群</span><br>
<span>                        case      0x0B: // ANC #$??</span><br>
<span>                        case      0x2B: // ANC #$??</span><br>
<span>                              MR_IM(); ANC();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0x8B: // ANE #$??</span><br>
<span>                              MR_IM(); ANE();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0x6B: // ARR #$??</span><br>
<span>                              MR_IM(); ARR();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0x4B: // ASR #$??</span><br>
<span>                              MR_IM(); ASR();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0xC7: // DCP $??</span><br>
<span>                              MR_ZP(); DCP(); MW_ZP();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0xD7: // DCP $??,X</span><br>
<span>                              MR_ZX(); DCP(); MW_ZP();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0xCF: // DCP $????</span><br>
<span>                              MR_AB(); DCP(); MW_EA();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0xDF: // DCP $????,X</span><br>
<span>                              MR_AX(); DCP(); MW_EA();</span><br>
<span>                              ADD_CYCLE(7);</span><br>
<span>                              break;</span><br>
<span>                        case      0xDB: // DCP $????,Y</span><br>
<span>                              MR_AY(); DCP(); MW_EA();</span><br>
<span>                              ADD_CYCLE(7);</span><br>
<span>                              break;</span><br>
<span>                        case      0xC3: // DCP ($??,X)</span><br>
<span>                              MR_IX(); DCP(); MW_EA();</span><br>
<span>                              ADD_CYCLE(8);</span><br>
<span>                              break;</span><br>
<span>                        case      0xD3: // DCP ($??),Y</span><br>
<span>                              MR_IY(); DCP(); MW_EA();</span><br>
<span>                              ADD_CYCLE(8);</span><br>
<span>                              break;</span><br>
<span>                        case      0xE7: // ISB $??</span><br>
<span>                              MR_ZP(); ISB(); MW_ZP();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0xF7: // ISB $??,X</span><br>
<span>                              MR_ZX(); ISB(); MW_ZP();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0xEF: // ISB $????</span><br>
<span>                              MR_AB(); ISB(); MW_EA();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0xFF: // ISB $????,X</span><br>
<span>                              MR_AX(); ISB(); MW_EA();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0xFB: // ISB $????,Y</span><br>
<span>                              MR_AY(); ISB(); MW_EA();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0xE3: // ISB ($??,X)</span><br>
<span>                              MR_IX(); ISB(); MW_EA();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0xF3: // ISB ($??),Y</span><br>
<span>                              MR_IY(); ISB(); MW_EA();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0xBB: // LAS $????,Y</span><br>
<span>                              MR_AY(); LAS(); CHECK_EA();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0xA7: // LAX $??</span><br>
<span>                              MR_ZP(); LAX();</span><br>
<span>                              ADD_CYCLE(3);</span><br>
<span>                              break;</span><br>
<span>                        case      0xB7: // LAX $??,Y</span><br>
<span>                              MR_ZY(); LAX();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0xAF: // LAX $????</span><br>
<span>                              MR_AB(); LAX();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0xBF: // LAX $????,Y</span><br>
<span>                              MR_AY(); LAX(); CHECK_EA();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0xA3: // LAX ($??,X)</span><br>
<span>                              MR_IX(); LAX();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0xB3: // LAX ($??),Y</span><br>
<span>                              MR_IY(); LAX(); CHECK_EA();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0xAB: // LXA #$??</span><br>
<span>                              MR_IM(); LXA();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0x27: // RLA $??</span><br>
<span>                              MR_ZP(); RLA(); MW_ZP();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0x37: // RLA $??,X</span><br>
<span>                              MR_ZX(); RLA(); MW_ZP();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0x2F: // RLA $????</span><br>
<span>                              MR_AB(); RLA(); MW_EA();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0x3F: // RLA $????,X</span><br>
<span>                              MR_AX(); RLA(); MW_EA();</span><br>
<span>                              ADD_CYCLE(7);</span><br>
<span>                              break;</span><br>
<span>                        case      0x3B: // RLA $????,Y</span><br>
<span>                              MR_AY(); RLA(); MW_EA();</span><br>
<span>                              ADD_CYCLE(7);</span><br>
<span>                              break;</span><br>
<span>                        case      0x23: // RLA ($??,X)</span><br>
<span>                              MR_IX(); RLA(); MW_EA();</span><br>
<span>                              ADD_CYCLE(8);</span><br>
<span>                              break;</span><br>
<span>                        case      0x33: // RLA ($??),Y</span><br>
<span>                              MR_IY(); RLA(); MW_EA();</span><br>
<span>                              ADD_CYCLE(8);</span><br>
<span>                              break;</span><br>
<span>                        case      0x67: // RRA $??</span><br>
<span>                              MR_ZP(); RRA(); MW_ZP();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0x77: // RRA $??,X</span><br>
<span>                              MR_ZX(); RRA(); MW_ZP();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0x6F: // RRA $????</span><br>
<span>                              MR_AB(); RRA(); MW_EA();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0x7F: // RRA $????,X</span><br>
<span>                              MR_AX(); RRA(); MW_EA();</span><br>
<span>                              ADD_CYCLE(7);</span><br>
<span>                              break;</span><br>
<span>                        case      0x7B: // RRA $????,Y</span><br>
<span>                              MR_AY(); RRA(); MW_EA();</span><br>
<span>                              ADD_CYCLE(7);</span><br>
<span>                              break;</span><br>
<span>                        case      0x63: // RRA ($??,X)</span><br>
<span>                              MR_IX(); RRA(); MW_EA();</span><br>
<span>                              ADD_CYCLE(8);</span><br>
<span>                              break;</span><br>
<span>                        case      0x73: // RRA ($??),Y</span><br>
<span>                              MR_IY(); RRA(); MW_EA();</span><br>
<span>                              ADD_CYCLE(8);</span><br>
<span>                              break;</span><br>
<span>                        case      0x87: // SAX $??</span><br>
<span>                              MR_ZP(); SAX(); MW_ZP();</span><br>
<span>                              ADD_CYCLE(3);</span><br>
<span>                              break;</span><br>
<span>                        case      0x97: // SAX $??,Y</span><br>
<span>                              MR_ZY(); SAX(); MW_ZP();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0x8F: // SAX $????</span><br>
<span>                              MR_AB(); SAX(); MW_EA();</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0x83: // SAX ($??,X)</span><br>
<span>                              MR_IX(); SAX(); MW_EA();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0xCB: // SBX #$??</span><br>
<span>                              MR_IM(); SBX();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0x9F: // SHA $????,Y</span><br>
<span>                              MR_AY(); SHA(); MW_EA();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0x93: // SHA ($??),Y</span><br>
<span>                              MR_IY(); SHA(); MW_EA();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0x9B: // SHS $????,Y</span><br>
<span>                              MR_AY(); SHS(); MW_EA();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0x9E: // SHX $????,Y</span><br>
<span>                              MR_AY(); SHX(); MW_EA();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0x9C: // SHY $????,X</span><br>
<span>                              MR_AX(); SHY(); MW_EA();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0x07: // SLO $??</span><br>
<span>                              MR_ZP(); SLO(); MW_ZP();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0x17: // SLO $??,X</span><br>
<span>                              MR_ZX(); SLO(); MW_ZP();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0x0F: // SLO $????</span><br>
<span>                              MR_AB(); SLO(); MW_EA();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0x1F: // SLO $????,X</span><br>
<span>                              MR_AX(); SLO(); MW_EA();</span><br>
<span>                              ADD_CYCLE(7);</span><br>
<span>                              break;</span><br>
<span>                        case      0x1B: // SLO $????,Y</span><br>
<span>                              MR_AY(); SLO(); MW_EA();</span><br>
<span>                              ADD_CYCLE(7);</span><br>
<span>                              break;</span><br>
<span>                        case      0x03: // SLO ($??,X)</span><br>
<span>                              MR_IX(); SLO(); MW_EA();</span><br>
<span>                              ADD_CYCLE(8);</span><br>
<span>                              break;</span><br>
<span>                        case      0x13: // SLO ($??),Y</span><br>
<span>                              MR_IY(); SLO(); MW_EA();</span><br>
<span>                              ADD_CYCLE(8);</span><br>
<span>                              break;</span><br>
<span>                        case      0x47: // SRE $??</span><br>
<span>                              MR_ZP(); SRE(); MW_ZP();</span><br>
<span>                              ADD_CYCLE(5);</span><br>
<span>                              break;</span><br>
<span>                        case      0x57: // SRE $??,X</span><br>
<span>                              MR_ZX(); SRE(); MW_ZP();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0x4F: // SRE $????</span><br>
<span>                              MR_AB(); SRE(); MW_EA();</span><br>
<span>                              ADD_CYCLE(6);</span><br>
<span>                              break;</span><br>
<span>                        case      0x5F: // SRE $????,X</span><br>
<span>                              MR_AX(); SRE(); MW_EA();</span><br>
<span>                              ADD_CYCLE(7);</span><br>
<span>                              break;</span><br>
<span>                        case      0x5B: // SRE $????,Y</span><br>
<span>                              MR_AY(); SRE(); MW_EA();</span><br>
<span>                              ADD_CYCLE(7);</span><br>
<span>                              break;</span><br>
<span>                        case      0x43: // SRE ($??,X)</span><br>
<span>                              MR_IX(); SRE(); MW_EA();</span><br>
<span>                              ADD_CYCLE(8);</span><br>
<span>                              break;</span><br>
<span>                        case      0x53: // SRE ($??),Y</span><br>
<span>                              MR_IY(); SRE(); MW_EA();</span><br>
<span>                              ADD_CYCLE(8);</span><br>
<span>                              break;</span><br>
<span>                        case      0xEB: // SBC #$?? (Unofficial)</span><br>
<span>                              MR_IM(); SBC();</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0x1A: // NOP (Unofficial)</span><br>
<span>                        case      0x3A: // NOP (Unofficial)</span><br>
<span>                        case      0x5A: // NOP (Unofficial)</span><br>
<span>                        case      0x7A: // NOP (Unofficial)</span><br>
<span>                        case      0xDA: // NOP (Unofficial)</span><br>
<span>                        case      0xFA: // NOP (Unofficial)</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0x80: // DOP (CYCLES 2)</span><br>
<span>                        case      0x82: // DOP (CYCLES 2)</span><br>
<span>                        case      0x89: // DOP (CYCLES 2)</span><br>
<span>                        case      0xC2: // DOP (CYCLES 2)</span><br>
<span>                        case      0xE2: // DOP (CYCLES 2)</span><br>
<span>                              R.PC++;</span><br>
<span>                              ADD_CYCLE(2);</span><br>
<span>                              break;</span><br>
<span>                        case      0x04: // DOP (CYCLES 3)</span><br>
<span>                        case      0x44: // DOP (CYCLES 3)</span><br>
<span>                        case      0x64: // DOP (CYCLES 3)</span><br>
<span>                              R.PC++;</span><br>
<span>                              ADD_CYCLE(3);</span><br>
<span>                              break;</span><br>
<span>                        case      0x14: // DOP (CYCLES 4)</span><br>
<span>                        case      0x34: // DOP (CYCLES 4)</span><br>
<span>                        case      0x54: // DOP (CYCLES 4)</span><br>
<span>                        case      0x74: // DOP (CYCLES 4)</span><br>
<span>                        case      0xD4: // DOP (CYCLES 4)</span><br>
<span>                        case      0xF4: // DOP (CYCLES 4)</span><br>
<span>                              R.PC++;</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0x0C: // TOP</span><br>
<span>                        case      0x1C: // TOP</span><br>
<span>                        case      0x3C: // TOP</span><br>
<span>                        case      0x5C: // TOP</span><br>
<span>                        case      0x7C: // TOP</span><br>
<span>                        case      0xDC: // TOP</span><br>
<span>                        case      0xFC: // TOP</span><br>
<span>                              R.PC+=2;</span><br>
<span>                              ADD_CYCLE(4);</span><br>
<span>                              break;</span><br>
<span>                        case      0x02:/* JAM */</span><br>
<span>                        case      0x12:/* JAM */</span><br>
<span>                        case      0x22:/* JAM */</span><br>
<span>                        case      0x32:/* JAM */</span><br>
<span>                        case      0x42:/* JAM */</span><br>
<span>                        case      0x52:/* JAM */</span><br>
<span>                        case      0x62:/* JAM */</span><br>
<span>                        case      0x72:/* JAM */</span><br>
<span>                        case      0x92:/* JAM */</span><br>
<span>                        case      0xB2:/* JAM */</span><br>
<span>                        case      0xD2:/* JAM */</span><br>
<span>                        case      0xF2:/* JAM */</span><br>
<span>                        default:</span><br>
<span>                              if( !Config.emulator.bIllegalOp ) {</span><br>
<span>                                        throw      CApp::GetErrorString( IDS_ERROR_ILLEGALOPCODE );</span><br>
<span>                                        goto      _execute_exit;</span><br>
<span>                              } else {</span><br>
<span>                                        R.PC--;</span><br>
<span>                                        ADD_CYCLE(4);</span><br>
<span>                              }</span><br>
<span>                              break;</span><br>
<span>//                        default:</span><br>
<span>//                              __assume(0);</span><br>
<span>                }</span><br>
<span>                if( nmi_request ) {</span><br>
<span>                        _NMI();</span><br>
<span>                } else</span><br>
<span>                if( irq_request ) {</span><br>
<span>                        _IRQ();</span><br>
<span>                }</span><br>
<span>                request_cycles -= exec_cycles;</span><br>
<span>                TOTAL_cycles += exec_cycles;</span><br>
<span>                // クロック同期処理</span><br>
<span>                mapper->Clock( exec_cycles );</span><br>
<span>#if      DPCM_SYNCCLOCK</span><br>
<span>                apu->SyncDPCM( exec_cycles );</span><br>
<span>#endif</span><br>
<span>                if( bClockProcess ) {</span><br>
<span>                        nes->Clock( exec_cycles );</span><br>
<span>                }</span><br>
<span>//                nes->Clock( exec_cycles );</span><br>
<span>      }</span><br>
<span>_execute_exit:</span><br>
<span>#if      !DPCM_SYNCCLOCK</span><br>
<span>      apu->SyncDPCM( TOTAL_cycles - OLD_cycles );</span><br>
<span>#endif</span><br>
<span>      return      TOTAL_cycles - OLD_cycles;</span><br>
<span>}</span><br>
</p><p><b>tuichu0425: </b><br>
<span>蛇精病</span><br>
</p><p><b>伊迪潘喵森: </b><br>
<span>你没写过单片机而已</span><br>
</p><p><b>wardenlym: </b><br>
<span>guna</span><br>
</p><p><b>Prushka: </b><br>
<span>您贵庚？</span><br>
</p><p><b>wardenlym: </b><br>
<span>        找了一个别人写的最简单的C/C++代码来看，直接放弃编程梦想        外野        3</span><br>
<span>96</span><br>
<span>wardenlym</span><br>
<span>2019-7-4 13:05</span><br>
<span>         我发明了一种在Win7下快键暂停python方法        外野        21</span><br>
<span>4034</span><br>
<span>CAMUS.net</span><br>
<span>2019-7-3 20:51</span><br>
<span>         补贴160亿,是谁给阿川出的馊主意？依我看,只要20亿就能搞定        外野        22</span><br>
<span>4155</span><br>
<span>CAMUS.net</span><br>
<span>2019-6-20 15:28</span><br>
<span>         请问有没有数学解题方法搬运为python的教程？ 图片附件 ... 1 2 3        外野        69</span><br>
<span>3792</span><br>
<span>ykrank</span><br>
<span>2019-6-15 14:50</span><br>
<span>         python真是太好用了：初中生好帮手——手动开平方根 图片附件 ... 1 2        外野        59</span><br>
<span>7251</span><br>
<span>Igarashi</span><br>
<span>2019-6-12 15:48</span><br>
<span>         欧盟5G用自家设备，即使多650亿美元，不是左手倒右手？ ... 1 2        外野        49</span><br>
<span>4388</span><br>
<span>梁皇无忌</span><br>
<span>2019-6-10 21:48</span><br>
<span>         python真是太好用了—— 下载文件，保持原来的目录结构。        外野        15</span><br>
<span>2720</span><br>
<span>obiy</span><br>
<span>2019-6-9 02:56</span><br>
<span>         阿川其实是全球自由贸易的守护者吗？        外野        6</span><br>
<span>1501</span><br>
<span>烤烤鱼ω</span><br>
<span>2019-5-29 19:22</span><br>
<span>         阿川家以前吃用人家的只管发纸,现想用物产来换,不是良心吗 ... 1 2        外野        31</span><br>
<span>5670</span><br>
<span>ZATEmkII</span><br>
<span>2019-5-28 22:16</span><br>
<span>         汝妻子吾自养之，汝勿虑也。        外野        2</span><br>
<span>869</span><br>
<span>nagitoY</span><br>
<span>2019-5-21 23:24</span><br>
<span>         《鸿门宴》項王大怒，若沛公不从子房，硬抗到底会如何？        外野        29</span><br>
<span>5220</span><br>
<span>wuxan94</span><br>
<span>2019-5-21 14:36</span><br>
<span>         让大家见识见识，什么叫专业设计。 ... 1 2 3 4 5 6        外野        177</span><br>
<span>23375</span><br>
<span>minichaos</span><br>
<span>2019-5-20 17:25</span><br>
<span>         python+selenium+Firefox 新闻一键搬运到外野 ... 1 2</span><br>
</p><p><b>ColinWine: </b><br>
<span>单片机的？这也不复杂呀</span><br>
</p><p><b>UCCU1102: </b><br>
<span>所以来写shell吖！</span><br>
<span>vim hello.sh</span><br>
<span>---------</span><br>
<span>#！/bin/bash </span><br>
<span>echo “Hello word!” </span><br>
</p><p><b>dazzle: </b><br>
<span>上来就贴2000行的代码，你给泥潭交钱了吗</span><br>
</p><p><b>Ra_Cailum: </b><br>
<span>07年的号，何必呢</span><br>
</p><p><b>HMHM: </b><br>
<span>罪恶的宏与指针与转型与地址运算。不细看代码我都知道有这些硬玩意劝退。</span><br>
</p><p><b>物理毒狗: </b><br>
<span>俺寻思最简单的不都是hello world吗？楼主发这一大串有啥心理活动？</span><br>
<span>-- 来自 能搜索的 Stage1官方 Android客户端</span><br>
</p><p><b>matrixtheory: </b><br>
<span>神tm最简单</span><br>
<span>----发送自 STAGE1 App for Android.</span><br>
</p><p><b>real_zyf: </b><br>
<span> 本帖最后由 real_zyf 于 2019-7-4 13:24 编辑 </span><br>
<span>6502是美国MOS Technology公司推出的一种8位的CPU</span><br>
<span>这是模拟红白机的cpu？</span><br>
</p><p><b>Linjiangzhu: </b><br>
<span>我现在严重怀疑你是新型的巨魔</span><br>
<span>专门钓鱼程序员</span><br>
<span>该叫你什么？PY侠？</span><br>
</p><p><b>aithinkso: </b><br>
<span>6502还在生产吗</span><br>
</p><p><b>BlackFinger: </b><br>
<span>6502? 是fc模拟器吧，这个有一定难度，不能叫最简单了</span><br>
</p><p><b>脑洞: </b><br>
<span>一看这开头一堆宏，想起了我的单片机</span><br>
</p><p><b>thq: </b><br>
<span>UCCU1102 发表于 2019-7-4 13:08</span><br>
<span>所以来写shell吖！</span><br>
<span>vim hello.sh</span><br>
<span>---------</span><br>
<span>多大仇……</span><br>
</p><p><b>精钢魔像: </b><br>
<span>编程是编程，业务是业务。要看懂这段代码你得先知道6502 有那些寄存器和指令集</span><br>
<span>看不懂代码，首先原因是不知道业务</span><br>
</p><p><b>PENTAX-DA: </b><br>
<span>cf，没搜到 hello</span><br>
</p><p><b>graysonqsq: </b><br>
<span>楼主是沙雕，以上</span><br>
</p><p><b>SSL4064G: </b><br>
<span>我竟然点进来之前就意识到是不是什么cpu模拟器的代码</span><br>
</p><p><b>StrangerJ: </b><br>
<span>学c++看这个代码，有病？</span><br>
</p><p><b>Litccc: </b><br>
<span>#include<reg52.h></span><br>
<span>sbit LED = P0^0;</span><br>
<span>void main(){   //void 即函数类型</span><br>
<span>    //以下为声明语句部分</span><br>
<span>    unsigned int i = 0;//定义一个无符号整型变量 i，并赋初值 0</span><br>
<span>    //以下为执行语句部分</span><br>
<span>    while (1){</span><br>
<span>      LED = 0;//点亮小灯</span><br>
<span>      for (i=0; i<30000; i++);    //延时一段时间</span><br>
<span>      LED = 1;//熄灭小灯</span><br>
<span>      for (i=0; i<30000; i++);//延时一段时间</span><br>
<span>    }</span><br>
<span>}</span><br>
<span>我寻思这个单片机程序比你那简单多了吧</span><br>
</p><p><b>洗刷刷: </b><br>
<span>Litccc 发表于 2019-7-4 13:48</span><br>
<span>我寻思这个单片机程序比你那简单多了吧</span><br>
<span>你这个延时有点粗暴啊</span><br>
</p><p><b>Litccc: </b><br>
<span>洗刷刷 发表于 2019-7-4 13:50</span><br>
<span>你这个延时有点粗暴啊</span><br>
<span>网上随便找了一个</span><br>
</p><p><b>fio: </b><br>
<span>Linjiangzhu 发表于 2019-7-4 13:20</span><br>
<span>我现在严重怀疑你是新型的巨魔</span><br>
<span>专门钓鱼程序员</span><br>
<span>该叫你什么？PY侠？</span><br>
<span>昨天我还很认真回了这lz一个win32 api的帖</span><br>
</p><p><b>CAMUS.net: </b><br>
<span>fio 发表于 2019-7-4 13:58</span><br>
<span>昨天我还很认真回了这lz一个win32 api的帖</span><br>
<span>我很认真的试了，GetKeyboardState要怎么用</span><br>
</p><p><b>saisi: </b><br>
<span>想学写fc模拟器吗</span><br>
</p><p><b>处男鉴黄师: </b><br>
<span>单片机、嵌入式这些低贱的硬件级玩意儿岂是高贵的码农看得上眼的？</span><br>
</p><p><b>雷之: </b><br>
<span>这一看就是和硬件有关系的代码，这也叫最简单？</span><br>
</p><p><b>亡亡鱼: </b><br>
<span>Litccc 发表于 2019-7-4 13:48</span><br>
<span>我寻思这个单片机程序比你那简单多了吧</span><br>
<span>你这直接循环不sleep真的是和cpu过不去吗</span><br>
<span>—— 来自 HUAWEI EML-AL00, Android 9上的 S1Next-鹅版 v2.1.0-play</span><br>
</p><p><b>real_zyf: </b><br>
<span>洗刷刷 发表于 2019-7-4 13:50</span><br>
<span>你这个延时有点粗暴啊</span><br>
<span>单片机正常操作，因为指令时间明确可知，所以可以这样简单粗暴</span><br>
</p><p><b>hunterkiller: </b><br>
<span>这不是挺好的么....</span><br>
<span>又不是p=p->next?p->next:p这种混乱邪恶的代码</span><br>
</p><p><b>real_zyf: </b><br>
<span>亡亡鱼 发表于 2019-7-4 14:13</span><br>
<span>你这直接循环不sleep真的是和cpu过不去吗</span><br>
<span>—— 来自 HUAWEI EML-AL00, Android 9上的 S1Next-鹅版 v2.1. ...</span><br>
<span>单片机正常操作，8051裸奔没有操作系统更加没有sleep，而且整个cpu就是你独占的</span><br>
</p><p><b>jctc: </b><br>
<span>我草</span><br>
<span>这写的也太难了吧</span><br>
<span>完全看不懂</span><br>
<span>写这个的月薪肯定上1万块了吧</span><br>
<span>肯定是我们这些吊死一辈子都无法企及的工资</span><br>
</p><p><b>斜阳: </b><br>
<span>你找谁写的，还用日语注释</span><br>
</p><p><b>Lunamos: </b><br>
<span> 本帖最后由 Lunamos 于 2019-7-4 16:17 编辑 </span><br>
<span>用C写6502挺简单的，你看着复杂，其实理解了6502的工作原理以后会觉得这些代码都是非常直观的。</span><br>
<span>比较难的是用Verilog写，有很多坑等着你。我尝试给6502加流水线，看了7天的modelsim波形，后面一星期我的眼睛看什么全都是绿线。</span><br>
</p><p><b>lwa190212: </b><br>
<span>你又熟悉这个硬件，也不需要你懂，你只要用封装好的东西就行了</span><br>
<span>还是你的需求需要用到这个级别的硬件调用来提升效率？</span><br>
</p><p><b>晴空怜: </b><br>
<span>这不是6502模拟器嘛，原来还用js写过，其实就是照着文档搓</span><br>
<span>但是我觉得gpu部分比这个复杂多了</span><br>
</p><p><b>伊迪潘喵森: </b><br>
<span> 本帖最后由 伊迪潘喵森 于 2019-7-4 14:57 编辑 </span><br>
<span>洗刷刷 发表于 2019-7-4 13:50</span><br>
<span>你这个延时有点粗暴啊</span><br>
<span>码农刚看单片机就会被这种代码震撼到，然而这是标准写法，大部分玩具，仪器，plc里面的传感器驱动都这么写的…………</span><br>
<span>因为单片机跑的都是单线程，而且计时器个数也就两三个，根本不会留着用来做短计时</span><br>
</p><p><b>对线: </b><br>
<span>是我对最简单这三个字有什么误解？</span><br>
</p><p><b>洗刷刷: </b><br>
<span>伊迪潘喵森 发表于 2019-7-4 14:56</span><br>
<span>码农刚看单片机就会被这种代码震撼到，然而这是标准写法，大部分玩具，仪器，plc里面的传感器驱动 ...</span><br>
<span>原来如此，不需要多线程，能保证频率固定的话，的确能起到该起的作用。不过写这东西一定很痛苦...</span><br>
</p><p><b>traburiss: </b><br>
<span>你那个不叫简单的代码。</span><br>
<span>简单的代码:</span><br>
<span>package com.test;</span><br>
<span>public class Test{</span><br>
<span>      public static void main(String[] args){</span><br>
<span>                  system.out.println("hello world");</span><br>
<span>      }</span><br>
<span>}</span><br>
<span>更简单的代码1:</span><br>
<span> console.info("hello world")</span><br>
<span>更简单的代码2:</span><br>
<span>print("hello world")</span><br>
<span>—— 来自 Xiaomi Mi Note 2, Android 8.0.0上的 S1Next-鹅版 v2.1.2</span><br>
</p><p><b>perfaceNext: </b><br>
<span>单片机的代码吧，好歹当年学过这个，不搞硬件这些都不用学，来学python吧，简单实用，易上手，无论工作学习都是非常好的</span><br>
</p><p><b>UnderWear: </b><br>
<span>hunterkiller 发表于 2019-7-4 14:22</span><br>
<span>这不是挺好的么....</span><br>
<span>又不是p=p->next?p->next:p这种混乱邪恶的代码</span><br>
<span>这个只有一层 ？：结构，算是相当清新的代码了</span><br>
</p><p><b>田多宇光: </b><br>
<span>亡亡鱼 发表于 2019-7-4 14:13</span><br>
<span>你这直接循环不sleep真的是和cpu过不去吗</span><br>
<span>—— 来自 HUAWEI EML-AL00, Android 9上的 S1Next-鹅版 v2.1. ...</span><br>
<span>单片机都这样</span><br>
</p><p><b>皇帝雅西加: </b><br>
<span>搞嵌入式尤其是单片机才需要这么写代码啊，C++又不是只能用来写硬件类底层开发</span><br>
</p><p><b>imosuke: </b><br>
<span>钓你🐴呢</span><br>
<span>-- 来自 能手机投票的 Stage1官方 Android客户端</span><br>
</p>]]></content:encoded>
      <guid isPermaLink="false">1844205[0-50]</guid>
    </item>
  </channel>
</rss>
