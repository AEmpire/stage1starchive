<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>算法题求教（动态规划？）</title>
    <link>https://bbs.saraba1st.com/2b/</link>
    <description>算法题求教（动态规划？）</description>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <generator>python-feedgen</generator>
    <lastBuildDate>Thu, 09 Jul 2020 19:23:56 +0000</lastBuildDate>
    <item>
      <title>算法题求教（动态规划？）[0-50]</title>
      <link>https://bbs.saraba1st.com/2b/thread-1843221-1-1.html</link>
      <description>算法题求教（动态规划？）&#13;
自定义矩阵求从最左边到最右边所经过的最大值最小的路径，怎么解？路径只能上下左右四个方向，不能斜线移动
&#13;
例：
&#13;
5 4// (生成一个5x4的随机矩阵）
&#13;
2 1 0 8
&#13;
3 7 3 5
&#13;
3 1 2 4
&#13;
9 0 4 6
&#13;
5 3 2 3
&#13;
这里 所经过的最大值最小的路径应该是3-1-0-3-2-3
&#13;
2 2
&#13;
3 0
&#13;
1 2
&#13;
这里所经过的最大值最小的从左到右的路径应该是 1 - 2
&#13;
和求经过的值总和最小的路径的题有点像，但又略复杂点，最近蛋疼在刷题，这题卡了我半天</description>
      <content:encoded><![CDATA[<p><b>皇帝雅西加: </b><br>
<span>算法题求教（动态规划？）</span><br>
<span>自定义矩阵求从最左边到最右边所经过的最大值最小的路径，怎么解？路径只能上下左右四个方向，不能斜线移动</span><br>
<span>例：</span><br>
<span>5 4// (生成一个5x4的随机矩阵）</span><br>
<span>2 1 0 8</span><br>
<span>3 7 3 5</span><br>
<span>3 1 2 4</span><br>
<span>9 0 4 6</span><br>
<span>5 3 2 3</span><br>
<span>这里 所经过的最大值最小的路径应该是3-1-0-3-2-3</span><br>
<span>2 2</span><br>
<span>3 0</span><br>
<span>1 2</span><br>
<span>这里所经过的最大值最小的从左到右的路径应该是 1 - 2</span><br>
<span>和求经过的值总和最小的路径的题有点像，但又略复杂点，最近蛋疼在刷题，这题卡了我半天</span><br>
</p><p><b>best: </b><br>
<span>bfs+dfs</span><br>
</p><p><b>汤大鸡: </b><br>
<span> 本帖最后由 汤大鸡 于 2019-6-30 06:55 编辑 </span><br>
<span>看错题目了</span><br>
<span>又想了一下，大概还是类似dijkstra，每次拓展一步（最小的），因为你不可能绕一圈把当前最大值变小</span><br>
</p><p><b>kts1mg: </b><br>
<span>感觉是flyod？或者对左边的点分别做dijkstra？</span><br>
</p><p><b>Hieda: </b><br>
<span>网络流秒了</span><br>
<span>其实这题是最小生成树（MST）</span><br>
</p><p><b>jason_gideon: </b><br>
<span> 本帖最后由 jason_gideon 于 2019-6-30 06:53 编辑 </span><br>
<span>汤大鸡 发表于 2019-6-30 06:41</span><br>
<span>多加一个起始点和一个终止点，做一个有向图，把点的值转到边上，然后求单源最短路径 ...</span><br>
<span>Dijkstra?</span><br>
<span>我理解的题目意思里没有要求最短路径。</span><br>
<span>只要求从第一个column走到最后一个column。这条路径中的每一点（MUD的深度）越小越好？</span><br>
<span>我觉着这题可以参考一下leetcode 79。但是怎么设定DFS终点到最后一个column不太清楚。</span><br>
</p><p><b>汤大鸡: </b><br>
<span>jason_gideon 发表于 2019-6-30 06:50</span><br>
<span>Dijkstra?</span><br>
<span>我理解的题目意思里没有要求最短路径。</span><br>
<span>只要求从第一个column走到最后一个column。这条路径中 ...</span><br>
<span>我的，看错题了</span><br>
</p><p><b>jason_gideon: </b><br>
<span>Hieda 发表于 2019-6-30 06:48</span><br>
<span>网络流秒了</span><br>
<span>其实这题是最小生成树（MST）</span><br>
<span>COL0选个最小的点，然后MST？请问MST有例子或者题号吗。。</span><br>
</p><p><b>qaweqa: </b><br>
<span> 本帖最后由 qaweqa 于 2019-6-30 07:42 编辑 </span><br>
<span>用优先队列跑bfs(类似dij)</span><br>
<span>————————————————————————</span><br>
<span>说的详细一点吧，这个题要求最小瓶颈路。</span><br>
<span>我们用类似最短路的方式，最左一列的元素入队。</span><br>
<span>我们令入队元素用(x,y,z)表示到点(x,y)瓶颈为z。</span><br>
<span>优先队列每次出队瓶颈最小的，显然此时对于(x,y)来说仅出队第一次一定为最优解。</span><br>
<span>最后对右边一列的最小瓶颈取一次min就是答案了。</span><br>
</p><p><b>Hieda: </b><br>
<span> 本帖最后由 Hieda 于 2019-6-30 07:07 编辑 </span><br>
<span>jason_gideon 发表于 2019-6-30 06:54</span><br>
<span>COL0选个最小的点，然后MST？请问MST有例子或者题号吗。。</span><br>
<span>例子不知道，可以抄下维基百科的代码</span><br>
<span>思路就是左边加个起始点（指向每个点的边权值是这个点的值）跑个MST，然后最右边所有点枚举一下最小的答案是哪个</span><br>
<span>简单（但可能不严谨的）证明：假设MST没有找到最优解，那么一定存在一个不在MST上的路径从起始点到右边，且这个路径的最大边比MST上所有边都小</span><br>
<span>如果是这样，这个边会被加进MST，所以这种情况不存在</span><br>
</p><p><b>汤大鸡: </b><br>
<span> 本帖最后由 汤大鸡 于 2019-6-30 07:11 编辑 </span><br>
<span>jason_gideon 发表于 2019-6-30 06:50</span><br>
<span>Dijkstra?</span><br>
<span>我理解的题目意思里没有要求最短路径。</span><br>
<span>只要求从第一个column走到最后一个column。这条路径中的 ...</span><br>
<span>假设S包含所有到过的点，每次取其中的v，v是S中mud最小的而且还有相邻的点不在S中，更新v相邻但不再S中的点的mud</span><br>
</p><p><b>河孢子: </b><br>
<span>很像最小路径和那道题，建议去看看找下思路，总感觉这道题看着有什么贪心策略。</span><br>
</p><p><b>mrmiywj: </b><br>
<span> 本帖最后由 mrmiywj 于 2019-6-30 07:39 编辑 </span><br>
<span>d, the min-max value in the path to (i,j)</span><br>
<span>path = (x,y), the previous index in the min-max path to reach (i,j) is (x,y)</span><br>
<span>d = min(d, d), starter case is i = 0 or j = 0, update corresponding path</span><br>
<span>for j == m - 1, iterate i to find the min-max path value to reach the right side, then use path to backtrace the path.</span><br>
<span>------</span><br>
<span>Nvm, I did not find it's a 4-way move. </span><br>
</p><p><b>一色彩羽的家人: </b><br>
<span>翻出来运筹学课本研究一下</span><br>
</p><p><b>macos: </b><br>
<span>听的不太懂，照例1应该是23310323才是最左最右吧，例2应该是302</span><br>
</p><p><b>充气型夏娃: </b><br>
<span> 本帖最后由 充气型夏娃 于 2019-6-30 07:55 编辑 </span><br>
<span>Perform topological sort;</span><br>
<span>for each vertex x in topological order</span><br>
<span>        for each outgoing edge (x, w) {</span><br>
<span>                // Perform edge relaxation </span><br>
<span>                if ( D(x)+w(x,w)>D(w) )</span><br>
<span>                {</span><br>
<span>                        D(w)=D(x)+w(x,w);</span><br>
<span>                        // x is the preceding vertex in the longest path prevVertex(w)=x;</span><br>
<span>                } </span><br>
<span>}</span><br>
</p><p><b>illjay: </b><br>
<span>最小生成树算法（MST）</span><br>
<span>—— 来自 HUAWEI VCE-AL00, Android 9上的 S1Next-鹅版 v2.1.2</span><br>
</p><p><b>Sliverstrike: </b><br>
<span>能不能按照从大到小的顺序剔除网格里的数字，然后判断一下走不走的通，</span><br>
<span>直到走不通了就是最小数字和最小路径？</span><br>
</p><p><b>citrus: </b><br>
<span>最短路径问题有多种算法。最省事直接用Floyd-Warshall，改都不用改</span><br>
</p><p><b>best: </b><br>
<span>话说第二个例子为啥是1-2不能是2-2</span><br>
</p><p><b>kugayama1369: </b><br>
<span>这题倒着推好推一点</span><br>
</p><p><b>光荣的小学生: </b><br>
<span>这是一个动态规划，不难的</span><br>
<span>实际上最难的是不同列不同行，取最小</span><br>
</p><p><b>海底铁锚: </b><br>
<span>优先队列+BFS，先把第一列所有点都放到BFS里面，然后权值以小为优先去跑。</span><br>
<span>二分答案然后check能不能从左边到右边也是一个方法。不过比起上面方法时间复杂度会比较大。</span><br>
</p><p><b>海底铁锚: </b><br>
<span> 本帖最后由 海底铁锚 于 2019-6-30 11:10 编辑 </span><br>
<span>找的是一条从左到右的路径，使得路径上的最大值最小。</span><br>
<span>这种最大值最小或者最小值最大的问题一般来说先想到的是二分答案然后check可行性，那么时间复杂度是O(n*m*log2(max(aij)))</span><br>
<span>不过带优先队列的BFS做点优化剪枝就能做到近似O(n*m)。但因为优先队列自带的log复杂度，如果没做好剪枝会因为队列存太多元素使得时间稍大。</span><br>
<span>至于最小生成树，不知道你们怎么做，但是如果单纯找一个最小的点开始生成是错的。</span><br>
<span>样例：</span><br>
<span>9 9 9 9 9</span><br>
<span>9 9 0 9 9</span><br>
<span>9 9 9 9 9</span><br>
<span>1 1 1 1 1</span><br>
<span>9 9 9 9 9</span><br>
<span>实际上也不是找最短路径</span><br>
<span>1 1 9 1 1</span><br>
<span>9 1 9 1 9</span><br>
<span>9 1 9 1 9</span><br>
<span>9 1 9 1 9</span><br>
<span>9 1 1 1 9</span><br>
<span>仔细看了下10L的解法，具体实现和BFS其实差不多...</span><br>
</p><p><b>R.I.P: </b><br>
<span> 本帖最后由 R.I.P 于 2019-6-30 11:06 编辑 </span><br>
<span>当然是二分答案每次traverse一下看看左右联不联通啊。。要再快一点可以把所有cell排好序，整个并查集慢慢往里加</span><br>
</p><p><b>cxn: </b><br>
<span>穷举</span><br>
</p><p><b>kugayama1369: </b><br>
<span>想了一下，动规是可以的，但是每层要扫两遍，从上到下一遍，再从下到上扫一遍</span><br>
</p><p><b>Hieda: </b><br>
<span> 本帖最后由 Hieda 于 2019-6-30 11:40 编辑 </span><br>
<span>海底铁锚 发表于 2019-6-30 11:03</span><br>
<span>找的是一条从左到右的路径，使得路径上的最大值最小。</span><br>
<span>这种最大值最小或者最小值最大的问题一般来说先想到 ...</span><br>
<span>是的，基本上如果用prim来生成MST，写出来的代码和这种类BFS很像</span><br>
<span>但是思考起来简单呀，能reduce为什么要重复造轮子呢</span><br>
</p><p><b>海底铁锚: </b><br>
<span>Hieda 发表于 2019-06-30 11:38:58</span><br>
<span>但是思考起来简单呀，能reduce为什么要重复造轮子呢我是acmer，这种bfs写起来也就五分钟的事情。也就无所谓造不造轮子了。</span><br>
<span>-- 来自 能搜索的 Stage1官方 Android客户端</span><br>
</p><p><b>steambun: </b><br>
<span>感觉dfs+greedy也可以解这个题？从最右边的column开始倒着推，或者从左边的column开始正着推都可以。比如如果倒着推，最右边的column每一个点都作为starting point试一次，dfs找neighbour里depth最小的点，直到走到最左边。5x4矩阵就要dfs试5次，这5次结果loop一遍取最小值。</span><br>
<span>======================</span><br>
<span>写了一下大概这样（应该还能再优化一下）</span><br>
<span>public class Solution {</span><br>
<span>    public static int getMinDepth(int[][] map)</span><br>
<span>    {</span><br>
<span>      if (map == null || map.length < 0 || map.length < 0) return -1;</span><br>
<span>      int minDepth = Integer.MAX_VALUE;</span><br>
<span>      int h = map.length;</span><br>
<span>      int w = map.length;</span><br>
<span>      for (int i = 0; i < h; i++)</span><br>
<span>      {</span><br>
<span>            System.out.println("Start from w = " + map);</span><br>
<span>            int currMinDepth = Math.max(map, _getMinDepth(map, i, w - 1, h, w, new boolean));</span><br>
<span>            System.out.println("curr Min is " + currMinDepth);</span><br>
<span>            minDepth = Math.min(minDepth, currMinDepth);</span><br>
<span>      }</span><br>
<span>      return (minDepth == Integer.MAX_VALUE) ? -1 : minDepth;</span><br>
<span>    }</span><br>
<span>    private static final int[][] m_dir2 =new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};</span><br>
<span>    private static int _getMinDepth(int[][] map, int x, int y, int h, int w, boolean[][] visited)</span><br>
<span>    {</span><br>
<span>      if (x < 0 || x >= h || y < 0 || y >= w || visited) return 0;</span><br>
<span>      visited = true;</span><br>
<span>      // Now we are at the left side of the route</span><br>
<span>      if (y == 0) return map;</span><br>
<span>      int[] depths = new int;</span><br>
<span>      int i = 0;</span><br>
<span>      for (int[] dir : m_dir2 ) depths = _getDepth(map, x + dir, y + dir, h, w, visited);</span><br>
<span>      int nextMinDepth = Integer.MAX_VALUE;</span><br>
<span>      for (int depth : depths) nextMinDepth = Math.min(nextMinDepth, depth);</span><br>
<span>      for (i = 0; i < 4; i++)</span><br>
<span>      {</span><br>
<span>            if (depths == nextMinDepth) break;</span><br>
<span>      }</span><br>
<span>      System.out.println("At [" + x + "," + y + "] nextMinDepth " + nextMinDepth + " Next [" + (x + m_dir2) + "," + (y + m_dir2) + "]");</span><br>
<span>      return Math.max(nextMinDepth, _getMinDepth(map, x + m_dir2, y + m_dir2, h, w, visited));</span><br>
<span>    }</span><br>
<span>    private static int _getDepth(int[][] map, int x, int y, int h, int w, boolean[][] visited)</span><br>
<span>    {</span><br>
<span>      if (x < 0 || x >= h || y < 0 || y >= w || visited) return Integer.MAX_VALUE;</span><br>
<span>      return map;</span><br>
<span>    }</span><br>
<span>}</span><br>
</p><p><b>steambun: </b><br>
<span>hmm多试了几个情况，上面的解法在四周depth相同的情况下可能会出现走回右边错过最优解的情况...</span><br>
</p><p><b>jue3365387: </b><br>
<span>A*算法吧。。看看？</span><br>
</p><p><b>jue3365387: </b><br>
<span>其实就是矩形寻路嘛</span><br>
</p><p><b>すぴぱら: </b><br>
<span>astar算法，四周查询优先级</span><br>
</p><p><b>jason_gideon: </b><br>
<span> 本帖最后由 jason_gideon 于 2019-7-1 00:44 编辑 </span><br>
<span>steambun 发表于 2019-6-30 14:47</span><br>
<span>hmm多试了几个情况，上面的解法在四周depth相同的情况下可能会出现走回右边错过最优解的情况... ...</span><br>
<span>右边走过来以后把右边设为非法值，然后当前层递归退出的时候再设置回原来的值呢？</span><br>
</p><p><b>UnderSilentEdge: </b><br>
<span>这个是最小瓶颈路问题 可以百度一下</span><br>
<span>-- 来自 能看大图的 Stage1官方 iOS客户端</span><br>
</p><p><b>steambun: </b><br>
<span>jason_gideon 发表于 2019-7-1 00:32</span><br>
<span>右边走过来以后把右边设为非法值，然后当前层递归退出的时候再设置回原来的值呢？ ...</span><br>
<span>递归退出的时候已经试完一个starting point了，这时候新建了一个visited[][] array for next starting point，所以如果我没理解错的话，你说的情况我写的代码里实现了呀。应该还是要用MST解吧。</span><br>
</p>]]></content:encoded>
      <guid isPermaLink="false">1843221[0-50]</guid>
    </item>
  </channel>
</rss>
